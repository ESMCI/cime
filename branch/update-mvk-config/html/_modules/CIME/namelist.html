

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CIME.namelist &mdash; CIME master documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=30d551ce"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            CIME
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../what_cime/index.html">What is CIME?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users_guide/index.html">Using the Case Control System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users_guide/index.html#configuring-the-case-control-system">Configuring the Case Control System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build_cpl/index.html">Building a Coupled Model with CIME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc_tools/index.html">Miscellaneous Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../glossary/index.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tools_user/index.html">User Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xml_files/index.html">XML Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CIME_api/modules.html">CIME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tools_api/modules.html">Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CIME</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">CIME.namelist</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for CIME.namelist</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module containing tools for dealing with Fortran namelists.</span>

<span class="sd">The public interface consists of the following functions:</span>
<span class="sd">- `character_literal_to_string`</span>
<span class="sd">- `compress_literal_list`</span>
<span class="sd">- `expand_literal_list`</span>
<span class="sd">- `fortran_namelist_base_value`</span>
<span class="sd">- `is_valid_fortran_name`</span>
<span class="sd">- `is_valid_fortran_namelist_literal`</span>
<span class="sd">- `literal_to_python_value`</span>
<span class="sd">- `merge_literal_lists`</span>
<span class="sd">- `parse`</span>
<span class="sd">- `string_to_character_literal`</span>

<span class="sd">In addition, the `Namelist` class represents a namelist held in memory.</span>

<span class="sd">For the moment, only a subset of namelist syntax is supported; specifically, we</span>
<span class="sd">assume that only variables of intrinsic type are used, and indexing/co-indexing</span>
<span class="sd">of arrays to set a portion of a variable is not supported. (However, null values</span>
<span class="sd">and repeated values may be used to set or fill a variable as indexing would.)</span>

<span class="sd">We also always assume that a period (&quot;.&quot;) is the decimal separator, not a comma</span>
<span class="sd">(&quot;,&quot;). We also assume that the file encoding is UTF-8 or some compatible format</span>
<span class="sd">(e.g. ASCII).</span>

<span class="sd">Otherwise, most Fortran syntax rules implemented here are compatible with</span>
<span class="sd">Fortran 2008 (which is largely the same as previous standards, and will be</span>
<span class="sd">similar to Fortran 2015). The only exceptions should be cases where (a) we</span>
<span class="sd">deliberately prohibit &quot;troublesome&quot; behavior that would be allowed by the</span>
<span class="sd">standard, or (b) we rely on conventions shared by all major compilers.</span>

<span class="sd">One important convention is that newline characters can be used to denote the</span>
<span class="sd">end of a record. This makes them equivalent to spaces at most locations in a</span>
<span class="sd">Fortran namelist, except that newlines also end comments, and they are ignored</span>
<span class="sd">entirely within strings.</span>

<span class="sd">While the treatment of comments in this module is standard, it may be somewhat</span>
<span class="sd">surprising. Namelist comments are only allowed in two situations:</span>

<span class="sd">(1) As the only thing on a line (aside from optional indentation with spaces).</span>
<span class="sd">(2) Immediately after a &quot;value separator&quot; (the space, newline, comma, or slash</span>
<span class="sd">after a value).</span>

<span class="sd">This implies that all lines except for the last are syntax errors, in this</span>
<span class="sd">example:</span>

<span class="sd">```</span>
<span class="sd">&amp;group_name! This is not a valid comment because it&#39;s after the group name.</span>
<span class="sd">foo ! Neither is this, because it&#39;s between a name and an equals sign.</span>
<span class="sd">= 2 ! Nor this, because it comes between the value and the following comma.</span>
<span class="sd">, bar = ! Nor this, because it&#39;s between an equals sign and a value.</span>
<span class="sd">2! Nor this, because it should be separated from the value by a comma or space.</span>
<span class="sd">bazz = 3 ! Nor this, because it comes between the value and the following slash.</span>
<span class="sd">/! This is fine, but technically it is outside the namelist, not a comment.</span>
<span class="sd">```</span>

<span class="sd">However, the above would actually be valid if all the &quot;comments&quot; were removed.</span>
<span class="sd">The Fortran standard is not clear about whether whitespace is allowed after</span>
<span class="sd">inline comments and before subsequent non-whitespace text (!), but this module</span>
<span class="sd">allows such whitespace, to preserve the sanity of both implementors and users.</span>

<span class="sd">The Fortran standard only applies to the interior of namelist groups, and not to</span>
<span class="sd">text between one namelist group and the next. This module assumes that namelist</span>
<span class="sd">groups are separated by (optional) whitespace and comments, and nothing else.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">###############################################################################</span>
<span class="c1">#</span>
<span class="c1"># Lexer/parser design notes</span>
<span class="c1">#</span>
<span class="c1"># The bulk of the complexity of this module is in the `_NamelistParser` object.</span>
<span class="c1"># Lexing, parsing, and translation of namelist data is all performed in a single</span>
<span class="c1"># pass (though it would be possible to use separate stages if needed). The style</span>
<span class="c1"># is that of a recursive descent parser, i.e. the functions correspond roughly</span>
<span class="c1"># to concepts in the Fortran namelist grammar, and top-down parsing is used.</span>
<span class="c1"># Parsing is done left-to-right with no backtracking.</span>
<span class="c1">#</span>
<span class="c1"># The most important attributes of a `_NamelistParser` are the input text</span>
<span class="c1"># itself (`_text`), and the current position in the text (`_pos`). The position</span>
<span class="c1"># is only changed via the `_advance` method, which also maintains line and</span>
<span class="c1"># column numbers for error-reporting purposes. The `_settings` attribute</span>
<span class="c1"># holds the final output, i.e. the variable name-value pairs.</span>
<span class="c1">#</span>
<span class="c1"># Parsing errors are signaled by one of two exceptions. The first is</span>
<span class="c1"># `_NamelistParseError`, which always signals an unrecoverable error. This is</span>
<span class="c1"># caught and translated to a user-visible error in `parse`. The second is</span>
<span class="c1"># `_NamelistEOF`, which may or may not represent a true error. During parsing of</span>
<span class="c1"># a standard namelist, it is treated in the same manner as</span>
<span class="c1"># `_NamelistParseError`, unless it occurs outside of any namelist group, in</span>
<span class="c1"># which case the `parse_namelist` method will catch it and return normally.</span>
<span class="c1">#</span>
<span class="c1"># The non-standard &quot;groupless&quot; format complicates things significantly by</span>
<span class="c1"># allowing an end-of-file at any location where a &#39;/&#39; would normally be. This is</span>
<span class="c1"># the reason for most of the `allow_eof` flags and related logic, since any</span>
<span class="c1"># `_NamelistEOF` exceptions raised must be caught and dealt with.</span>
<span class="c1">#</span>
<span class="c1">###############################################################################</span>

<span class="c1"># Disable these because of doctest, and because we don&#39;t typically follow the</span>
<span class="c1"># (rather specific) pylint naming conventions.</span>
<span class="c1"># pylint: disable=line-too-long,too-many-lines,invalid-name</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="c1"># Disable these because this is our standard setup</span>
<span class="c1"># pylint: disable=wildcard-import,unused-wildcard-import</span>

<span class="kn">from</span> <span class="nn">CIME.XML.standard_module_setup</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">CIME.utils</span> <span class="kn">import</span> <span class="n">expect</span><span class="p">,</span> <span class="n">string_in_list</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># Fortran syntax regular expressions.</span>
<span class="c1"># Variable names.</span>
<span class="c1"># FORTRAN_NAME_REGEX = re.compile(r&quot;(^[a-z][a-z0-9_]{0,62})(\([+-]?\d*:?[+-]?\d*:?[+-]?\d*\))?$&quot;, re.IGNORECASE)</span>
<span class="n">FORTRAN_NAME_REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;(^[a-z][a-z0-9_@]{0,62})                            #  The variable name</span>
<span class="sd">                                  (\(                                                   # begin optional index expression</span>
<span class="sd">                                  (([+-]?\d+)                                           # Single valued index</span>
<span class="sd">                                  |                                                     # or</span>
<span class="sd">                                  (([+-]?\d+)?:([+-]?\d+)?:?([+-]?\d+)?))               # colon seperated triplet</span>
<span class="sd">                                  \))?\s*$&quot;&quot;&quot;</span><span class="p">,</span>  <span class="c1"># end optional index expression</span>
    <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">FORTRAN_LITERAL_REGEXES</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># Integer literals.</span>
<span class="n">_int_re_string</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\+|-)?[0-9]+&quot;</span>
<span class="n">FORTRAN_LITERAL_REGEXES</span><span class="p">[</span><span class="s2">&quot;integer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;^&quot;</span> <span class="o">+</span> <span class="n">_int_re_string</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span>
<span class="c1"># Real/complex literals.</span>
<span class="n">_ieee_exceptional_re_string</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;inf(inity)?|nan(\([^)]+\))?&quot;</span>
<span class="n">_float_re_string</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;((\+|-)?([0-9]+(\.[0-9]*)?|\.[0-9]+)([ed]?</span><span class="si">{}</span><span class="s2">)?|</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">_int_re_string</span><span class="p">,</span> <span class="n">_ieee_exceptional_re_string</span>
<span class="p">)</span>
<span class="n">FORTRAN_LITERAL_REGEXES</span><span class="p">[</span><span class="s2">&quot;real&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="s2">&quot;^&quot;</span> <span class="o">+</span> <span class="n">_float_re_string</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span>
<span class="p">)</span>
<span class="n">FORTRAN_LITERAL_REGEXES</span><span class="p">[</span><span class="s2">&quot;complex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sa">r</span><span class="s2">&quot;^\([ \n]*&quot;</span>
    <span class="o">+</span> <span class="n">_float_re_string</span>
    <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;[ \n]*,[ \n]*&quot;</span>
    <span class="o">+</span> <span class="n">_float_re_string</span>
    <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;[ \n]*\)$&quot;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Character literals.</span>
<span class="n">_char_single_re_string</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&#39;[^&#39;]*(&#39;&#39;[^&#39;]*)*&#39;&quot;</span>
<span class="n">_char_double_re_string</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&quot;[^&quot;]*(&quot;&quot;[^&quot;]*)*&quot;&#39;</span>
<span class="n">FORTRAN_LITERAL_REGEXES</span><span class="p">[</span><span class="s2">&quot;character&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="s2">&quot;^(&quot;</span> <span class="o">+</span> <span class="n">_char_single_re_string</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span> <span class="o">+</span> <span class="n">_char_double_re_string</span> <span class="o">+</span> <span class="s2">&quot;)$&quot;</span>
<span class="p">)</span>
<span class="c1"># Logical literals.</span>
<span class="n">FORTRAN_LITERAL_REGEXES</span><span class="p">[</span><span class="s2">&quot;logical&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\.?[tf][^=/ \n]*$&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="c1"># Repeated value prefix.</span>
<span class="n">FORTRAN_REPEAT_PREFIX_REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[0-9]*[1-9]+[0-9]*\*&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="convert_bool">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.convert_bool">[docs]</a>
<span class="k">def</span> <span class="nf">convert_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to convert </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">value</span></div>



<div class="viewcode-block" id="is_valid_fortran_name">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.is_valid_fortran_name">[docs]</a>
<span class="k">def</span> <span class="nf">is_valid_fortran_name</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that a variable name is allowed in Fortran.</span>

<span class="sd">    The rules are:</span>
<span class="sd">    1. The name must start with a letter.</span>
<span class="sd">    2. All characters in a name must be alphanumeric (or underscores).</span>
<span class="sd">    3. The maximum name length is 63 characters.</span>
<span class="sd">    4. We only handle a single dimension !!!</span>

<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;a&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A(4)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A(::)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A(1:2:3)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A(1::)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A(:-2:)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A(1::+3)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A(1,3)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;2&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;_&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;abc#123&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;aLiBi_123&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A&quot; * 64)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_name(&quot;A&quot; * 63)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">FORTRAN_NAME_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="get_fortran_name_only">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.get_fortran_name_only">[docs]</a>
<span class="k">def</span> <span class="nf">get_fortran_name_only</span><span class="p">(</span><span class="n">full_var</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;remove array section if any and return only the variable name</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_name_only(&#39;foo&#39;)</span>
<span class="sd">    &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_name_only(&#39;foo(3)&#39;)</span>
<span class="sd">    &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_name_only(&#39;foo(::)&#39;)</span>
<span class="sd">    &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_name_only(&#39;foo(1::)&#39;)</span>
<span class="sd">    &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_name_only(&#39;foo(:+2:)&#39;)</span>
<span class="sd">    &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_name_only(&#39;foo(::-3)&#39;)</span>
<span class="sd">    &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_name_only(&#39;foo(::)&#39;)</span>
<span class="sd">    &#39;foo&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">FORTRAN_NAME_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">full_var</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_fortran_variable_indices">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.get_fortran_variable_indices">[docs]</a>
<span class="k">def</span> <span class="nf">get_fortran_variable_indices</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="n">varlen</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_any_len</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get indices from a fortran namelist variable as a triplet of minindex, maxindex and step</span>

<span class="sd">    &gt;&gt;&gt; get_fortran_variable_indices(&#39;foo(3)&#39;)</span>
<span class="sd">    (3, 3, 1)</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_variable_indices(&#39;foo(1:2:3)&#39;)</span>
<span class="sd">    (1, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_variable_indices(&#39;foo(::)&#39;, varlen=4)</span>
<span class="sd">    (1, 4, 1)</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_variable_indices(&#39;foo(::2)&#39;, varlen=4)</span>
<span class="sd">    (1, 4, 2)</span>
<span class="sd">    &gt;&gt;&gt; get_fortran_variable_indices(&#39;foo(::)&#39;, allow_any_len=True)</span>
<span class="sd">    (1, -1, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">FORTRAN_NAME_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
    <span class="p">(</span><span class="n">minindex</span><span class="p">,</span> <span class="n">maxindex</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">varlen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">minindex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">maxindex</span> <span class="o">=</span> <span class="n">minindex</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minindex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxindex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">allow_any_len</span> <span class="ow">and</span> <span class="n">maxindex</span> <span class="o">==</span> <span class="n">minindex</span><span class="p">:</span>
        <span class="n">maxindex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">expect</span><span class="p">(</span><span class="n">step</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Step size 0 not allowed&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">minindex</span><span class="p">,</span> <span class="n">maxindex</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span></div>



<div class="viewcode-block" id="fortran_namelist_base_value">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.fortran_namelist_base_value">[docs]</a>
<span class="k">def</span> <span class="nf">fortran_namelist_base_value</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Strip off whitespace and repetition syntax from a namelist value.</span>

<span class="sd">    &gt;&gt;&gt; fortran_namelist_base_value(&quot;&quot;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; fortran_namelist_base_value(&quot;f&quot;)</span>
<span class="sd">    &#39;f&#39;</span>
<span class="sd">    &gt;&gt;&gt; fortran_namelist_base_value(&quot;6*&quot;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; fortran_namelist_base_value(&quot;6*f&quot;)</span>
<span class="sd">    &#39;f&#39;</span>
<span class="sd">    &gt;&gt;&gt; fortran_namelist_base_value(&quot; \n6* \n&quot;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; fortran_namelist_base_value(&quot;\n 6*f\n &quot;)</span>
<span class="sd">    &#39;f&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Strip leading/trailing whitespace.</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Strip off repeated value prefix.</span>
    <span class="k">if</span> <span class="n">FORTRAN_REPEAT_PREFIX_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">string</span></div>



<div class="viewcode-block" id="character_literal_to_string">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.character_literal_to_string">[docs]</a>
<span class="k">def</span> <span class="nf">character_literal_to_string</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a Fortran character literal to a Python string.</span>

<span class="sd">    This function assumes (without checking) that `literal` is a valid literal.</span>

<span class="sd">    &gt;&gt;&gt; character_literal_to_string(&quot;&#39;blah&#39;&quot;)</span>
<span class="sd">    &#39;blah&#39;</span>
<span class="sd">    &gt;&gt;&gt; character_literal_to_string(&#39;&quot;blah&quot;&#39;)</span>
<span class="sd">    &#39;blah&#39;</span>
<span class="sd">    &gt;&gt;&gt; character_literal_to_string(&quot;&#39;don&#39;&#39;t&#39;&quot;)</span>
<span class="sd">    &quot;don&#39;t&quot;</span>
<span class="sd">    &gt;&gt;&gt; character_literal_to_string(&#39;&quot;&#39; + &#39;&quot;&quot;Hello!&quot;&quot;&#39; + &#39;&quot;&#39;)</span>
<span class="sd">    &#39;&quot;Hello!&quot;&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Figure out whether a quote or apostrophe is the delimiter.</span>
    <span class="n">delimiter</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">literal</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">):</span>
            <span class="n">delimiter</span> <span class="o">=</span> <span class="n">char</span>
    <span class="c1"># Find left and right edges of the string, extract middle.</span>
    <span class="n">left_pos</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
    <span class="n">right_pos</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
    <span class="n">new_literal</span> <span class="o">=</span> <span class="n">literal</span><span class="p">[</span><span class="n">left_pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">right_pos</span><span class="p">]</span>
    <span class="c1"># Replace escaped quote and apostrophe characters.</span>
    <span class="k">return</span> <span class="n">new_literal</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">delimiter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">)</span></div>



<div class="viewcode-block" id="string_to_character_literal">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.string_to_character_literal">[docs]</a>
<span class="k">def</span> <span class="nf">string_to_character_literal</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert a Python string to a Fortran character literal.</span>

<span class="sd">    This function always uses double quotes (&quot;) as the delimiter.</span>

<span class="sd">    &gt;&gt;&gt; string_to_character_literal(&#39;blah&#39;)</span>
<span class="sd">    &#39;&quot;blah&quot;&#39;</span>
<span class="sd">    &gt;&gt;&gt; string_to_character_literal(&quot;&#39;blah&#39;&quot;)</span>
<span class="sd">    &#39;&quot;\&#39;blah\&#39;&quot;&#39;</span>
<span class="sd">    &gt;&gt;&gt; string_to_character_literal(&#39;She said &quot;Hi!&quot;.&#39;)</span>
<span class="sd">    &#39;&quot;She said &quot;&quot;Hi!&quot;&quot;.&quot;&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">string</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span></div>



<div class="viewcode-block" id="is_valid_fortran_namelist_literal">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.is_valid_fortran_namelist_literal">[docs]</a>
<span class="k">def</span> <span class="nf">is_valid_fortran_namelist_literal</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Determine whether a literal is valid in a Fortran namelist.</span>

<span class="sd">    Note that kind parameters are *not* allowed in namelists, which simplifies</span>
<span class="sd">    this check a bit. Internal whitespace is allowed for complex and character</span>
<span class="sd">    literals only. BOZ literals and compiler extensions (e.g. backslash escapes)</span>
<span class="sd">    are not allowed.</span>

<span class="sd">    Null values, however, are allowed for all types. This means that passing in</span>
<span class="sd">    a string containing nothing but spaces and newlines will always cause</span>
<span class="sd">    `True` to be returned. Repetition (e.g. `5*&#39;a&#39;`) is also allowed, including</span>
<span class="sd">    repetition of null values.</span>

<span class="sd">    Detailed rules and examples follow.</span>

<span class="sd">    Integers: Must be a sequence of one or more digits, with an optional sign.</span>

<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot; &quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;\n&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;5*&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;1&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;5*1&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot; 5*1&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;5* 1&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;5 *1&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;a&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot; 1&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;1 &quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;1 2&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;0123456789&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;+22&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;-26&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;2A&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;1_8&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;2.1&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;integer&quot;, &quot;2e6&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    Reals:</span>
<span class="sd">    - For fixed-point format, there is an optional sign, followed by an integer</span>
<span class="sd">    part, or a decimal point followed by a fractional part, or both.</span>
<span class="sd">    - Scientific notation is allowed, with an optional, case-insensitive &quot;e&quot; or</span>
<span class="sd">    &quot;d&quot; followed by an optionally-signed integer exponent. (Either the &quot;e&quot;/&quot;d&quot;</span>
<span class="sd">    or a sign must be present to separate the number from the exponent.)</span>
<span class="sd">    - The (case-insensitive) strings &quot;inf&quot;, &quot;infinity&quot;, and &quot;nan&quot; are allowed.</span>
<span class="sd">    NaN values can also contain additional information in parentheses, e.g.</span>
<span class="sd">    &quot;NaN(x1234ABCD)&quot;.</span>

<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;a&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot; 1&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1 &quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1 2&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;+1&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;-1&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1.&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1.5&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;.5&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;+.5&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;.&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;+&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1e6&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1e-6&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1e+6&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;.5e6&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1e&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1D6&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1q6&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1+6&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1.6.5&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1._8&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;1,5&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;inf&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;INFINITY&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;NaN&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;nan(x56)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;real&quot;, &quot;nan())&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    Complex numbers:</span>
<span class="sd">    - A pair of real numbers enclosed by parentheses, and separated by a comma.</span>
<span class="sd">    - Any number of spaces or newlines may be placed before or after each real.</span>

<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;()&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;(,)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;( ,\n)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;(a,2.)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;(1.,b)&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;(1,2)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;(-1.e+06,+2.d-5)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;(inf,NaN)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;(  1. ,  2. )&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;( \n \n 1. \n,\n 2.\n)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot; (1.,2.)&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;complex&quot;, &quot;(1.,2.) &quot;)</span>
<span class="sd">    True</span>

<span class="sd">    Character sequences (strings):</span>
<span class="sd">    - Must begin and end with the same delimiter character, either a single</span>
<span class="sd">    quote (apostrophe), or a double quote (quotation mark).</span>
<span class="sd">    - Whichever character is used as a delimiter must not appear in the</span>
<span class="sd">    string itself, unless it appears in doubled pairs (e.g. &#39;&#39;&#39;&#39; or &quot;&#39;&quot; are the</span>
<span class="sd">    two ways of representing a string containing a single apostrophe).</span>
<span class="sd">    - Note that newlines cannot be represented in a namelist character literal</span>
<span class="sd">    since they are interpreted as an &quot;end of record&quot;, but they are allowed as</span>
<span class="sd">    long as they don&#39;t come between one of the aforementioned double pairs of</span>
<span class="sd">    characters.</span>

<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;&#39;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot; &#39;&#39;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;\n&#39;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;&#39;\n&#39;&#39;&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;&#39;&#39;&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;&#39;&#39;&#39;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;&#39;&#39;Cookie&#39;&#39;&#39;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;&#39;&#39;Cookie&#39;&#39;&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;\&quot;&#39;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &quot;&#39;\&quot;\&quot;&#39;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;&quot;&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;&quot; &#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;\n&quot;&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;&quot;\n&quot;&quot;&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;&quot;&#39; + &#39;&quot;&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;&quot;&#39; + &#39;&quot;&quot;&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;&#39; + &#39;&quot;&quot;Cookie&quot;&quot;&#39; + &#39;&quot;&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;&quot;Cookie&quot;&quot;&#39; + &#39;&quot;&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;\&#39;&quot;&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;character&quot;, &#39;&quot;\&#39;\&#39;&quot;&#39;)</span>
<span class="sd">    True</span>

<span class="sd">    Logicals:</span>
<span class="sd">    - Must contain a (case-insensitive) &quot;t&quot; or &quot;f&quot;.</span>
<span class="sd">    - This must be either the first nonblank character, or the second following</span>
<span class="sd">    a period.</span>
<span class="sd">    - The rest of the string is ignored, but cannot contain a comma, newline,</span>
<span class="sd">    equals sign, slash, or space (except that trailing spaces are allowed and</span>
<span class="sd">    ignored).</span>

<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;t&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;F&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.T&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.f&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot; f&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot; .t&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;at&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.TRUE.&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.false.&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.TEXAS$&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.f=&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.f/1&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.t\nted&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.Fant astic&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_valid_fortran_namelist_literal(&quot;logical&quot;, &quot;.t2 &quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expect</span><span class="p">(</span>
        <span class="n">type_</span> <span class="ow">in</span> <span class="n">FORTRAN_LITERAL_REGEXES</span><span class="p">,</span>
        <span class="s2">&quot;Invalid Fortran type for a namelist: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">type_</span><span class="p">)),</span>
    <span class="p">)</span>
    <span class="c1"># Strip off whitespace and repetition.</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">fortran_namelist_base_value</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="c1"># Null values are always allowed.</span>
    <span class="k">if</span> <span class="n">string</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">FORTRAN_LITERAL_REGEXES</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="literal_to_python_value">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.literal_to_python_value">[docs]</a>
<span class="k">def</span> <span class="nf">literal_to_python_value</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert a Fortran literal string to a Python value.</span>

<span class="sd">    This function assumes that the input contains a single value, i.e.</span>
<span class="sd">    repetition syntax is not used. The type can be specified by passing a string</span>
<span class="sd">    as the `type_` argument, or if this option is not provided, this function</span>
<span class="sd">    will attempt to autodetect the variable type.</span>

<span class="sd">    Note that it is not possible to be certain whether a literal like &quot;123&quot; is</span>
<span class="sd">    intended to represent an integer or a floating-point value, however, nor can</span>
<span class="sd">    we be certain of the precision that will be used to hold this value in</span>
<span class="sd">    actual Fortran code. We also cannot use the optional information in a NaN</span>
<span class="sd">    float, so this will cause the function to throw an error if that information</span>
<span class="sd">    is present (e.g. a string like &quot;NAN(1234)&quot; will cause an error).</span>

<span class="sd">    The Python type of the return value is as follows for different `type_`</span>
<span class="sd">    arguments:</span>
<span class="sd">    &quot;character&quot; - `str`</span>
<span class="sd">    &quot;complex&quot; - `complex`</span>
<span class="sd">    &quot;integer&quot; - `int`</span>
<span class="sd">    &quot;logical&quot; - `bool`</span>
<span class="sd">    &quot;real&quot; - `float`</span>

<span class="sd">    If a null value is input (i.e. the empty string), `None` will be returned.</span>

<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;&#39;She&#39;&#39;s a winner!&#39;&quot;)</span>
<span class="sd">    &quot;She&#39;s a winner!&quot;</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;1&quot;)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;1.&quot;)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot; (\n 1. , 2. )\n &quot;)</span>
<span class="sd">    (1+2j)</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;.true.&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;Fortune&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;bacon&quot;) # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    CIMEError: ERROR: &#39;bacon&#39; is not a valid literal for any Fortran type.</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;1&quot;, type_=&quot;real&quot;)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;bacon&quot;, type_=&quot;logical&quot;) # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    CIMEError: ERROR: &#39;bacon&#39; is not a valid literal of type &#39;logical&#39;.</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;1&quot;, type_=&quot;booga&quot;) # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    CIMEError: ERROR: Invalid Fortran type for a namelist: &#39;booga&#39;</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;2*1&quot;) # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    CIMEError: ERROR: Cannot use repetition syntax in literal_to_python_value</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;&quot;)</span>
<span class="sd">    &gt;&gt;&gt; literal_to_python_value(&quot;-1.D+10&quot;)</span>
<span class="sd">    -10000000000.0</span>
<span class="sd">    &gt;&gt;&gt; shouldRaise(ValueError, literal_to_python_value, &quot;nan(1234)&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expect</span><span class="p">(</span>
        <span class="n">FORTRAN_REPEAT_PREFIX_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;Cannot use repetition syntax in literal_to_python_value&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Handle null value.</span>
    <span class="k">if</span> <span class="n">fortran_namelist_base_value</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">type_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Autodetect type.</span>
        <span class="k">for</span> <span class="n">test_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;character&quot;</span><span class="p">,</span> <span class="s2">&quot;complex&quot;</span><span class="p">,</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="s2">&quot;logical&quot;</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_valid_fortran_namelist_literal</span><span class="p">(</span><span class="n">test_type</span><span class="p">,</span> <span class="n">literal</span><span class="p">):</span>
                <span class="n">type_</span> <span class="o">=</span> <span class="n">test_type</span>
                <span class="k">break</span>
        <span class="n">expect</span><span class="p">(</span>
            <span class="n">type_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> is not a valid literal for any Fortran type.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">literal</span><span class="p">)),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Check that type is valid.</span>
        <span class="n">expect</span><span class="p">(</span>
            <span class="n">is_valid_fortran_namelist_literal</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">literal</span><span class="p">),</span>
            <span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> is not a valid literal of type </span><span class="si">{!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">literal</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="c1"># Conversion for each type.</span>
    <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;character&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">character_literal_to_string</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;complex&quot;</span><span class="p">:</span>
        <span class="n">literal</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">(&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">real_part</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">imag_part</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">real_part</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">imag_part</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;integer&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;logical&quot;</span><span class="p">:</span>
        <span class="n">literal</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">literal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;tT&quot;</span>
    <span class="k">elif</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;real&quot;</span><span class="p">:</span>
        <span class="n">literal</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span></div>



<div class="viewcode-block" id="expand_literal_list">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.expand_literal_list">[docs]</a>
<span class="k">def</span> <span class="nf">expand_literal_list</span><span class="p">(</span><span class="n">literals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expands a list of literal values to get rid of repetition syntax.</span>

<span class="sd">    &gt;&gt;&gt; expand_literal_list([])</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; expand_literal_list([&#39;true&#39;])</span>
<span class="sd">    [&#39;true&#39;]</span>
<span class="sd">    &gt;&gt;&gt; expand_literal_list([&#39;1&#39;, &#39;2&#39;, &#39;f*&#39;, &#39;3*3&#39;, &#39;5&#39;])</span>
<span class="sd">    [&#39;1&#39;, &#39;2&#39;, &#39;f*&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; expand_literal_list([&#39;2*f*&#39;])</span>
<span class="sd">    [&#39;f*&#39;, &#39;f*&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expanded</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">literal</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">FORTRAN_REPEAT_PREFIX_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>
            <span class="n">expanded</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expanded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expanded</span></div>



<div class="viewcode-block" id="compress_literal_list">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.compress_literal_list">[docs]</a>
<span class="k">def</span> <span class="nf">compress_literal_list</span><span class="p">(</span><span class="n">literals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Uses repetition syntax to shorten a literal list.</span>

<span class="sd">    &gt;&gt;&gt; compress_literal_list([])</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; compress_literal_list([&#39;true&#39;])</span>
<span class="sd">    [&#39;true&#39;]</span>
<span class="sd">    &gt;&gt;&gt; compress_literal_list([&#39;1&#39;, &#39;2&#39;, &#39;f*&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;5&#39;])</span>
<span class="sd">    [&#39;1&#39;, &#39;2&#39;, &#39;f*&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; compress_literal_list([&#39;f*&#39;, &#39;f*&#39;])</span>
<span class="sd">    [&#39;f*&#39;, &#39;f*&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compressed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">compressed</span>
    <span class="c1"># for right now do not compress</span>
    <span class="n">do_compression</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">do_compression</span><span class="p">:</span>
        <span class="c1"># Start with the first literal.</span>
        <span class="n">old_literal</span> <span class="o">=</span> <span class="n">literals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">num_reps</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">literal</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">literal</span> <span class="o">==</span> <span class="n">old_literal</span><span class="p">:</span>
                <span class="c1"># For each new literal, if it matches the old one, it increases the</span>
                <span class="c1"># number of repetitions by one.</span>
                <span class="n">num_reps</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise, write out the previous literal and start tracking the</span>
                <span class="c1"># new one.</span>
                <span class="n">rep_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_reps</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">num_reps</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_literal</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">compressed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rep_str</span> <span class="o">+</span> <span class="n">old_literal</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">compressed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rep_str</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">old_literal</span><span class="p">))</span>
                <span class="n">old_literal</span> <span class="o">=</span> <span class="n">literal</span>
                <span class="n">num_reps</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">rep_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_reps</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">num_reps</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_literal</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">compressed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rep_str</span> <span class="o">+</span> <span class="n">old_literal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compressed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rep_str</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">old_literal</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">compressed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">literal</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">compressed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">compressed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">literal</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">compressed</span></div>



<div class="viewcode-block" id="merge_literal_lists">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.merge_literal_lists">[docs]</a>
<span class="k">def</span> <span class="nf">merge_literal_lists</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge two lists of literal value strings.</span>

<span class="sd">    The `overwrite` values have higher precedence, so will overwrite the</span>
<span class="sd">    `default` values. However, if `overwrite` contains null values, or is</span>
<span class="sd">    shorter than `default` (and thus implicitly ends in null values), the</span>
<span class="sd">    elements of `default` will be used where `overwrite` is null.</span>

<span class="sd">    &gt;&gt;&gt; merge_literal_lists([], [])</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; merge_literal_lists([&#39;true&#39;], [&#39;false&#39;])</span>
<span class="sd">    [&#39;false&#39;]</span>
<span class="sd">    &gt;&gt;&gt; merge_literal_lists([], [&#39;false&#39;])</span>
<span class="sd">    [&#39;false&#39;]</span>
<span class="sd">    &gt;&gt;&gt; merge_literal_lists([&#39;true&#39;], [&#39;&#39;])</span>
<span class="sd">    [&#39;true&#39;]</span>
<span class="sd">    &gt;&gt;&gt; merge_literal_lists([], [&#39;&#39;])</span>
<span class="sd">    [&#39;&#39;]</span>
<span class="sd">    &gt;&gt;&gt; merge_literal_lists([&#39;true&#39;], [])</span>
<span class="sd">    [&#39;true&#39;]</span>
<span class="sd">    &gt;&gt;&gt; merge_literal_lists([&#39;true&#39;], [])</span>
<span class="sd">    [&#39;true&#39;]</span>
<span class="sd">    &gt;&gt;&gt; merge_literal_lists([&#39;3*false&#39;, &#39;3*true&#39;], [&#39;true&#39;, &#39;4*&#39;, &#39;false&#39;])</span>
<span class="sd">    [&#39;true&#39;, &#39;false&#39;, &#39;false&#39;, &#39;true&#39;, &#39;true&#39;, &#39;false&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">default</span> <span class="o">=</span> <span class="n">expand_literal_list</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
    <span class="n">overwrite</span> <span class="o">=</span> <span class="n">expand_literal_list</span><span class="p">(</span><span class="n">overwrite</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">default_elem</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_elem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="n">def_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
    <span class="n">ovw_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">overwrite</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ovw_len</span> <span class="o">&lt;</span> <span class="n">def_len</span><span class="p">:</span>
        <span class="n">merged</span><span class="p">[</span><span class="n">ovw_len</span><span class="p">:</span><span class="n">def_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span><span class="p">[</span><span class="n">ovw_len</span><span class="p">:</span><span class="n">def_len</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">merged</span><span class="p">[</span><span class="n">def_len</span><span class="p">:</span><span class="n">ovw_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">overwrite</span><span class="p">[</span><span class="n">def_len</span><span class="p">:</span><span class="n">ovw_len</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">compress_literal_list</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span></div>



<div class="viewcode-block" id="parse">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.parse">[docs]</a>
<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">in_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">groupless</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">convert_tab_to_space</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse a Fortran namelist.</span>

<span class="sd">    The `in_file` argument must be either a `str` or `unicode` object containing</span>
<span class="sd">    a file name, or a text I/O object with a `read` method that returns the text</span>
<span class="sd">    of the namelist.</span>

<span class="sd">    Alternatively, the `text` argument can be provided, in which case it must be</span>
<span class="sd">    the text of the namelist itself.</span>

<span class="sd">    The `groupless` argument changes namelist parsing in two ways:</span>

<span class="sd">    1. `parse` allows an alternate file format where no group names or slashes</span>
<span class="sd">       are present. In effect, the file is parsed as if an invisible, arbitrary</span>
<span class="sd">       group name was prepended, and an invisible slash was appended. However,</span>
<span class="sd">       if any group names actually are present, the file is parsed normally.</span>
<span class="sd">    2. The return value of this function is not a `Namelist` object. Instead a</span>
<span class="sd">       single, flattened dictionary of name-value pairs is returned.</span>

<span class="sd">    The `convert_tab_to_space` option can be used to force all tabs in the file</span>
<span class="sd">    to be converted to spaces, and is on by default. Note that this will usually</span>
<span class="sd">    allow files that use tabs as whitespace to be parsed. However, the</span>
<span class="sd">    implementation of this option is crude; it converts *all* tabs in the file,</span>
<span class="sd">    including those in character literals. (Note that there are many characters</span>
<span class="sd">    that cannot be passed in via namelist in any standard way, including &#39;\n&#39;,</span>
<span class="sd">    so it is already a bad idea to assume that the namelist will preserve</span>
<span class="sd">    whitespace in strings, aside from simple spaces.)</span>

<span class="sd">    The return value, if `groupless=False`, is a `Namelist` object.</span>

<span class="sd">    All names and values returned are ultimately unicode strings. E.g. a value</span>
<span class="sd">    of &quot;6*2&quot; is returned as that string; it is not converted to 6 copies of the</span>
<span class="sd">    Python integer `2`. Null values are returned as the empty string (&quot;&quot;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expect</span><span class="p">(</span>
        <span class="n">in_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;Must specify an input file or text to the namelist parser.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">expect</span><span class="p">(</span>
        <span class="n">in_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">text</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;Cannot specify both input file and text to the namelist parser.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reading namelist at: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">in_file</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">in_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">in_file_obj</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">in_file_obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">in_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reading namelist from file object&quot;</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">in_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">convert_tab_to_space</span><span class="p">:</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">namelist_dict</span> <span class="o">=</span> <span class="n">_NamelistParser</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">groupless</span><span class="p">)</span><span class="o">.</span><span class="n">parse_namelist</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">_NamelistEOF</span><span class="p">,</span> <span class="n">_NamelistParseError</span><span class="p">)</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="c1"># Deal with unexpected EOF or other parsing errors.</span>
        <span class="n">expect</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">groupless</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">namelist_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Namelist</span><span class="p">(</span><span class="n">namelist_dict</span><span class="p">)</span></div>



<div class="viewcode-block" id="shouldRaise">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.shouldRaise">[docs]</a>
<span class="k">def</span> <span class="nf">shouldRaise</span><span class="p">(</span><span class="n">eclass</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function to make doctests py3 compatible</span>
<span class="sd">    http://python3porting.com/problems.html#running-doctests</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">eclass</span><span class="p">):</span>
            <span class="k">raise</span>
        <span class="k">return</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected exception </span><span class="si">%s</span><span class="s2"> not raised&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">eclass</span><span class="p">))</span></div>



<div class="viewcode-block" id="Namelist">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist">[docs]</a>
<span class="k">class</span> <span class="nc">Namelist</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class representing a Fortran namelist.</span>

<span class="sd">    Public methods:</span>
<span class="sd">    __init__</span>
<span class="sd">    delete_variable</span>
<span class="sd">    get_group_names</span>
<span class="sd">    get_value</span>
<span class="sd">    get_variable_names</span>
<span class="sd">    get_variable_value</span>
<span class="sd">    merge_nl</span>
<span class="sd">    set_variable_value</span>
<span class="sd">    write</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a new `Namelist` object.</span>

<span class="sd">        The `groups` argument is a dictionary associating group names to</span>
<span class="sd">        dictionaries of name/value pairs. If omitted, an empty namelist object</span>
<span class="sd">        is created.</span>

<span class="sd">        Unless you are deliberately creating an empty `Namelist`, it is easier/</span>
<span class="sd">        safer to use `parse` than to directly call this constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">groups</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="n">expect</span><span class="p">(</span><span class="n">group_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot; Got None in groups </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">groups</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">variable_name</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">][</span><span class="n">variable_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">][</span>
                        <span class="n">variable_name</span>
                    <span class="p">]</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<div class="viewcode-block" id="Namelist.clean_groups">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.clean_groups">[docs]</a>
    <span class="k">def</span> <span class="nf">clean_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span></div>


<div class="viewcode-block" id="Namelist.get_group_names">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.get_group_names">[docs]</a>
    <span class="k">def</span> <span class="nf">get_group_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of all groups in the namelist.</span>

<span class="sd">        &gt;&gt;&gt; Namelist().get_group_names()</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; sorted(parse(text=&#39;&amp;foo / &amp;bar /&#39;).get_group_names())</span>
<span class="sd">        [&#39;bar&#39;, &#39;foo&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="Namelist.get_variable_names">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.get_variable_names">[docs]</a>
    <span class="k">def</span> <span class="nf">get_variable_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of all variables in the given namelist group.</span>

<span class="sd">        If the specified group is not in the namelist, returns an empty list.</span>

<span class="sd">        &gt;&gt;&gt; Namelist().get_variable_names(&#39;foo&#39;)</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; x = parse(text=&#39;&amp;foo bar=,bazz=true,bazz(2)=fred,bang=6*&quot;&quot;/&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_variable_names(&#39;fOo&#39;))</span>
<span class="sd">        [&#39;bang&#39;, &#39;bar&#39;, &#39;bazz&#39;, &#39;bazz(2)&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x = parse(text=&#39;&amp;foo bar=,bazz=true,bang=6*&quot;&quot;/&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_variable_names(&#39;fOo&#39;))</span>
<span class="sd">        [&#39;bang&#39;, &#39;bar&#39;, &#39;bazz&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x = parse(text=&#39;&amp;foo bar(::)=,bazz=false,bazz(2)=true,bazz(:2:)=6*&quot;&quot;/&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_variable_names(&#39;fOo&#39;))</span>
<span class="sd">        [&#39;bar(::)&#39;, &#39;bazz&#39;, &#39;bazz(2)&#39;, &#39;bazz(:2:)&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gn</span> <span class="o">=</span> <span class="n">string_in_list</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gn</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="Namelist.get_variable_value">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.get_variable_value">[docs]</a>
    <span class="k">def</span> <span class="nf">get_variable_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the value of the specified variable.</span>

<span class="sd">        This function always returns a non-empty list containing strings. If the</span>
<span class="sd">        specified `group_name` or `variable_name` is not present, `[&#39;&#39;]` is</span>
<span class="sd">        returned.</span>

<span class="sd">        &gt;&gt;&gt; Namelist().get_variable_value(&#39;foo&#39;, &#39;bar&#39;)</span>
<span class="sd">        [&#39;&#39;]</span>
<span class="sd">        &gt;&gt;&gt; parse(text=&#39;&amp;foo bar=1,2 /&#39;).get_variable_value(&#39;foo&#39;, &#39;bazz&#39;)</span>
<span class="sd">        [&#39;&#39;]</span>
<span class="sd">        &gt;&gt;&gt; parse(text=&#39;&amp;foo bar=1,2 /&#39;).get_variable_value(&#39;foO&#39;, &#39;Bar&#39;)</span>
<span class="sd">        [&#39;1&#39;, &#39;2&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gn</span> <span class="o">=</span> <span class="n">string_in_list</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gn</span><span class="p">:</span>
            <span class="n">vn</span> <span class="o">=</span> <span class="n">string_in_list</span><span class="p">(</span><span class="n">variable_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">vn</span><span class="p">:</span>
                <span class="c1"># Make a copy of the list so that any modifications done by the caller</span>
                <span class="c1"># don&#39;t modify the internal values.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">][</span><span class="n">vn</span><span class="p">][:]</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Namelist.get_value">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.get_value">[docs]</a>
    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the value of a uniquely-named variable.</span>

<span class="sd">        This function is similar to `get_variable_value`, except that it does</span>
<span class="sd">        not require a `group_name`, and it requires that the `variable_name` be</span>
<span class="sd">        unique across all groups.</span>

<span class="sd">        &gt;&gt;&gt; parse(text=&#39;&amp;foo bar=1 / &amp;bazz bar=1 /&#39;).get_value(&#39;bar&#39;)  # doctest: +ELLIPSIS +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        CIMEError: ERROR: Namelist.get_value: Variable {} is present in multiple groups: ...</span>
<span class="sd">        &gt;&gt;&gt; parse(text=&#39;&amp;foo bar=1 / &amp;bazz /&#39;).get_value(&#39;Bar&#39;)</span>
<span class="sd">        [&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; parse(text=&#39;&amp;foo bar(2)=1 / &amp;bazz /&#39;).get_value(&#39;Bar(2)&#39;)</span>
<span class="sd">        [&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; parse(text=&#39;&amp;foo / &amp;bazz /&#39;).get_value(&#39;bar&#39;)</span>
<span class="sd">        [&#39;&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">possible_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">:</span>
            <span class="n">vnt</span> <span class="o">=</span> <span class="n">string_in_list</span><span class="p">(</span><span class="n">variable_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">vnt</span><span class="p">:</span>
                <span class="n">vn</span> <span class="o">=</span> <span class="n">vnt</span>
                <span class="n">possible_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>
        <span class="n">expect</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">possible_groups</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;Namelist.get_value: Variable </span><span class="si">{}</span><span class="s2"> is present in multiple groups: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">possible_groups</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">possible_groups</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">possible_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">vn</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Namelist.set_variable_value">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.set_variable_value">[docs]</a>
    <span class="k">def</span> <span class="nf">set_variable_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">var_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the value of the specified variable.</span>

<span class="sd">        &gt;&gt;&gt; x = parse(text=&#39;&amp;foo bar=1 /&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_value(&#39;foo&#39;, &#39;bar&#39;)</span>
<span class="sd">        [&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.set_variable_value(&#39;foo&#39;, &#39;bar(2)&#39;, [&#39;3&#39;], var_size=4)</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_value(&#39;foo&#39;, &#39;bar&#39;)</span>
<span class="sd">        [&#39;1&#39;, &#39;3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.set_variable_value(&#39;foo&#39;, &#39;bar(1)&#39;, [&#39;2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_value(&#39;foo&#39;, &#39;bar&#39;)</span>
<span class="sd">        [&#39;2&#39;, &#39;3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.set_variable_value(&#39;foo&#39;, &#39;bar&#39;, [&#39;1&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_value(&#39;foo&#39;, &#39;bar&#39;)</span>
<span class="sd">        [&#39;1&#39;, &#39;3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.set_variable_value(&#39;foo&#39;, &#39;bazz&#39;, [&#39;3&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.set_variable_value(&#39;Brack&#39;, &#39;baR&#39;, [&#39;4&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_value(&#39;foo&#39;, &#39;bazz&#39;)</span>
<span class="sd">        [&#39;3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_value(&#39;brack&#39;, &#39;bar&#39;)</span>
<span class="sd">        [&#39;4&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.set_variable_value(&#39;foo&#39;, &#39;red(2:6:2)&#39;, [&#39;2&#39;, &#39;4&#39;, &#39;6&#39;], var_size=12)</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_value(&#39;foo&#39;, &#39;red&#39;)</span>
<span class="sd">        [&#39;&#39;, &#39;2&#39;, &#39;&#39;, &#39;4&#39;, &#39;&#39;, &#39;6&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">value</span><span class="p">,</span>
            <span class="p">]</span>

        <span class="n">minindex</span><span class="p">,</span> <span class="n">maxindex</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">get_fortran_variable_indices</span><span class="p">(</span><span class="n">variable_name</span><span class="p">,</span> <span class="n">var_size</span><span class="p">)</span>
        <span class="n">variable_name</span> <span class="o">=</span> <span class="n">get_fortran_name_only</span><span class="p">(</span><span class="n">variable_name</span><span class="p">)</span>

        <span class="n">expect</span><span class="p">(</span>
            <span class="n">minindex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;Indices &lt; 1 not supported in CIME interface to fortran namelists... lower bound=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">minindex</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">gn</span> <span class="o">=</span> <span class="n">string_in_list</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gn</span> <span class="o">=</span> <span class="n">group_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">tlen</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">string_in_list</span><span class="p">(</span><span class="n">variable_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">vn</span><span class="p">:</span>
            <span class="n">tlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">][</span><span class="n">vn</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vn</span> <span class="o">=</span> <span class="n">variable_name</span>
            <span class="n">tlen</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">][</span><span class="n">vn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">minindex</span> <span class="o">&gt;</span> <span class="n">tlen</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">][</span><span class="n">vn</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">minindex</span> <span class="o">-</span> <span class="n">tlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">minindex</span><span class="p">,</span> <span class="n">maxindex</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">step</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">][</span><span class="n">vn</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">][</span><span class="n">vn</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">][</span><span class="n">vn</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span></div>


<div class="viewcode-block" id="Namelist.delete_variable">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.delete_variable">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete a variable from a specified group.</span>

<span class="sd">        If the specified group or variable does not exist, this is a no-op.</span>

<span class="sd">        &gt;&gt;&gt; x = parse(text=&#39;&amp;foo bar=1 /&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.delete_variable(&#39;FOO&#39;, &#39;BAR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.delete_variable(&#39;foo&#39;, &#39;bazz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.delete_variable(&#39;brack&#39;, &#39;bazz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_names(&#39;foo&#39;)</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; x.get_variable_names(&#39;brack&#39;)</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gn</span> <span class="o">=</span> <span class="n">string_in_list</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gn</span><span class="p">:</span>
            <span class="n">vn</span> <span class="o">=</span> <span class="n">string_in_list</span><span class="p">(</span><span class="n">variable_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">vn</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">gn</span><span class="p">][</span><span class="n">vn</span><span class="p">]</span></div>


<div class="viewcode-block" id="Namelist.merge_nl">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.merge_nl">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_nl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge this namelist object with another.</span>

<span class="sd">        Values in the invoking (`self`) `Namelist` will take precedence over</span>
<span class="sd">        values in the `other` `Namelist`, unless `overwrite=True` is passed in,</span>
<span class="sd">        in which case `other` values take precedence.</span>

<span class="sd">        &gt;&gt;&gt; x = parse(text=&#39;&amp;foo bar=1 bazz=,2 brat=3/&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = parse(text=&#39;&amp;foo bar=2 bazz=3*1 baker=4 / &amp;foo2 barter=5 /&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y.get_value(&#39;bazz&#39;)</span>
<span class="sd">        [&#39;1&#39;, &#39;1&#39;, &#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.merge_nl(y)</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_group_names())</span>
<span class="sd">        [&#39;foo&#39;, &#39;foo2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_variable_names(&#39;foo&#39;))</span>
<span class="sd">        [&#39;baker&#39;, &#39;bar&#39;, &#39;bazz&#39;, &#39;brat&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_variable_names(&#39;foo2&#39;))</span>
<span class="sd">        [&#39;barter&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;bar&#39;)</span>
<span class="sd">        [&#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;bazz&#39;)</span>
<span class="sd">        [&#39;1&#39;, &#39;2&#39;, &#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;brat&#39;)</span>
<span class="sd">        [&#39;3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;baker&#39;)</span>
<span class="sd">        [&#39;4&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;barter&#39;)</span>
<span class="sd">        [&#39;5&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x = parse(text=&#39;&amp;foo bar=1 bazz=,2 brat=3/&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = parse(text=&#39;&amp;foo bar=2 bazz=3*1 baker=4 / &amp;foo2 barter=5 /&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.merge_nl(y, overwrite=True)</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_group_names())</span>
<span class="sd">        [&#39;foo&#39;, &#39;foo2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_variable_names(&#39;foo&#39;))</span>
<span class="sd">        [&#39;baker&#39;, &#39;bar&#39;, &#39;bazz&#39;, &#39;brat&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sorted(x.get_variable_names(&#39;foo2&#39;))</span>
<span class="sd">        [&#39;barter&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;bar&#39;)</span>
<span class="sd">        [&#39;2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;bazz&#39;)</span>
<span class="sd">        [&#39;1&#39;, &#39;1&#39;, &#39;1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;brat&#39;)</span>
<span class="sd">        [&#39;3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;baker&#39;)</span>
<span class="sd">        [&#39;4&#39;]</span>
<span class="sd">        &gt;&gt;&gt; x.get_value(&#39;barter&#39;)</span>
<span class="sd">        [&#39;5&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pretty simple strategy: go through the entire other namelist, and</span>
        <span class="c1"># merge all values with this one&#39;s.</span>
        <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">variable_name</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">get_variable_names</span><span class="p">(</span><span class="n">group_name</span><span class="p">):</span>
                <span class="n">self_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_value</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">)</span>
                <span class="n">other_val</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_variable_value</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                    <span class="n">merged_val</span> <span class="o">=</span> <span class="n">merge_literal_lists</span><span class="p">(</span><span class="n">self_val</span><span class="p">,</span> <span class="n">other_val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">merged_val</span> <span class="o">=</span> <span class="n">merge_literal_lists</span><span class="p">(</span><span class="n">other_val</span><span class="p">,</span> <span class="n">self_val</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_variable_value</span><span class="p">(</span>
                    <span class="n">group_name</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">,</span> <span class="n">merged_val</span><span class="p">,</span> <span class="n">var_size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_val</span><span class="p">)</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="Namelist.get_group_variables">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.get_group_variables">[docs]</a>
    <span class="k">def</span> <span class="nf">get_group_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">):</span>
        <span class="n">group_variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">group_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">group_variables</span></div>


<div class="viewcode-block" id="Namelist.write">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">out_file</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">format_</span><span class="o">=</span><span class="s2">&quot;nml&quot;</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a the output data (normally fortran namelist) to the  out_file</span>

<span class="sd">        As with `parse`, the `out_file` argument can be either a file name, or a</span>
<span class="sd">        file object with a `write` method that accepts unicode. If specified,</span>
<span class="sd">        the `groups` argument specifies a subset of all groups to write out.</span>

<span class="sd">        If `out_file` is a file name, and `append=True` is passed in, the</span>
<span class="sd">        namelist will be appended to the named file instead of overwriting it.</span>
<span class="sd">        The `append` option has no effect if a file object is passed in.</span>

<span class="sd">        The `format_` option can be either &#39;nml&#39; (namelist) or &#39;rc&#39;, and</span>
<span class="sd">        specifies the file format. Formats other than &#39;nml&#39; may not support all</span>
<span class="sd">        possible output values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expect</span><span class="p">(</span>
            <span class="n">format_</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;nml&quot;</span><span class="p">,</span> <span class="s2">&quot;rc&quot;</span><span class="p">,</span> <span class="s2">&quot;nmlcontents&quot;</span><span class="p">),</span>
            <span class="s2">&quot;Namelist.write: unexpected output format </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">format_</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Writing namelist to: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out_file</span><span class="p">))</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span> <span class="k">if</span> <span class="n">append</span> <span class="k">else</span> <span class="s2">&quot;w&quot;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_obj</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span><span class="n">file_obj</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">format_</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="o">=</span><span class="n">sorted_groups</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Writing namelist to file object&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">format_</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="o">=</span><span class="n">sorted_groups</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_file</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">format_</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unwrapped version of `write` assuming that a file object is input.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">groups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">format_</span> <span class="o">==</span> <span class="s2">&quot;nml&quot;</span> <span class="ow">or</span> <span class="n">format_</span> <span class="o">==</span> <span class="s2">&quot;nmlcontents&quot;</span><span class="p">:</span>
            <span class="n">equals</span> <span class="o">=</span> <span class="s2">&quot; =&quot;</span>
        <span class="k">elif</span> <span class="n">format_</span> <span class="o">==</span> <span class="s2">&quot;rc&quot;</span><span class="p">:</span>
            <span class="n">equals</span> <span class="o">=</span> <span class="s2">&quot;:&quot;</span>
        <span class="k">if</span> <span class="n">sorted_groups</span><span class="p">:</span>
            <span class="n">group_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_names</span> <span class="o">=</span> <span class="n">groups</span>
        <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">group_name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">format_</span> <span class="o">==</span> <span class="s2">&quot;nml&quot;</span><span class="p">:</span>
                <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&amp;</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group_name</span><span class="p">))</span>
            <span class="c1"># allow empty group</span>
            <span class="k">if</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

                    <span class="c1"># @ is used in a namelist to put the same namelist variable in multiple groups</span>
                    <span class="c1"># in the write phase, all characters in the namelist variable name after</span>
                    <span class="c1"># the @ and including the @ should be removed</span>
                    <span class="k">if</span> <span class="s2">&quot;@&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;@.+$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                    <span class="c1"># To prettify things for long lists of values, build strings</span>
                    <span class="c1"># line-by-line.</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="s2">&quot;true&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_bool</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">group_name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">equals</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;  </span><span class="si">{}{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">equals</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span>
                            <span class="s2">&quot;true&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;false&quot;</span><span class="p">,</span>
                        <span class="p">):</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">convert_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">77</span><span class="p">:</span>
                            <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">value</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;      &quot;</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>
                    <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">group_name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">format_</span> <span class="o">==</span> <span class="s2">&quot;nml&quot;</span><span class="p">:</span>
                <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;/</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">format_</span> <span class="o">==</span> <span class="s2">&quot;nmlcontents&quot;</span><span class="p">:</span>
                <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Namelist.write_nuopc">
<a class="viewcode-back" href="../../CIME_api/CIME.html#CIME.namelist.Namelist.write_nuopc">[docs]</a>
    <span class="k">def</span> <span class="nf">write_nuopc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_file</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a nuopc config file out_file</span>

<span class="sd">        As with `parse`, the `out_file` argument can be either a file name, or a</span>
<span class="sd">        file object with a `write` method that accepts unicode. If specified,</span>
<span class="sd">        the `groups` argument specifies a subset of all groups to write out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Writing nuopc config file to: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out_file</span><span class="p">))</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_obj</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_nuopc</span><span class="p">(</span><span class="n">file_obj</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="o">=</span><span class="n">sorted_groups</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Writing nuopc config data to file object&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_nuopc</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="o">=</span><span class="n">sorted_groups</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_write_nuopc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_file</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unwrapped version of `write` assuming that a file object is input.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">groups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">sorted_groups</span><span class="p">:</span>
            <span class="n">group_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_names</span> <span class="o">=</span> <span class="n">groups</span>

        <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;_modelio&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_name</span>
                <span class="ow">and</span> <span class="s2">&quot;_attributes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_name</span>
                <span class="ow">and</span> <span class="s2">&quot;nuopc_&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_name</span>
                <span class="ow">and</span> <span class="s2">&quot;_no_group&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_name</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="s2">&quot;_attributes&quot;</span> <span class="ow">in</span> <span class="n">group_name</span> <span class="ow">or</span> <span class="s2">&quot;_modelio&quot;</span> <span class="ow">in</span> <span class="n">group_name</span><span class="p">:</span>
                <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">::</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group_name</span><span class="p">))</span>
                <span class="n">indent</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

                <span class="c1"># @ is used in a namelist to put the same namelist variable in multiple groups</span>
                <span class="c1"># in the write phase, all characters in the namelist variable name after</span>
                <span class="c1"># the @ and including the @ should be removed</span>
                <span class="k">if</span> <span class="s2">&quot;@&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;@.+$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                <span class="n">equals</span> <span class="o">=</span> <span class="s2">&quot; =&quot;</span>
                <span class="k">if</span> <span class="s2">&quot;_var&quot;</span> <span class="ow">in</span> <span class="n">group_name</span><span class="p">:</span>
                    <span class="n">equals</span> <span class="o">=</span> <span class="s2">&quot;:&quot;</span>

                <span class="c1"># To prettify things for long lists of values, build strings</span>
                <span class="c1"># line-by-line.</span>
                <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span> <span class="ow">or</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;False&quot;</span><span class="p">:</span>
                    <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;True&quot;</span><span class="p">,</span> <span class="s2">&quot;.true.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;False&quot;</span><span class="p">,</span> <span class="s2">&quot;.false.&quot;</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">indent</span><span class="p">:</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;     </span><span class="si">{}{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">equals</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">equals</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;False&quot;</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;True&quot;</span><span class="p">,</span> <span class="s2">&quot;.true.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s2">&quot;False&quot;</span><span class="p">,</span> <span class="s2">&quot;.false.&quot;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">77</span><span class="p">:</span>
                        <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;      &quot;</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">indent</span><span class="p">:</span>
                <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;::</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="kc">False</span></div>



<span class="k">class</span> <span class="nc">_NamelistEOF</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exception thrown for an unexpected end-of-file in a namelist.</span>

<span class="sd">    This is an internal helper class, and should never be raised in a context</span>
<span class="sd">    where it would be visible to a user. (Typically it should be caught and</span>
<span class="sd">    converted to some other error, or ignored.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `_NamelistEOF`, optionally using an error message.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_NamelistEOF</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_message</span> <span class="o">=</span> <span class="n">message</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an error message suitable for display.&quot;&quot;&quot;</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Unexpected end of file encountered in namelist.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot; (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span>


<span class="k">class</span> <span class="nc">_NamelistParseError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exception thrown when namelist input has a syntax error.</span>

<span class="sd">    This is an internal helper class, and should never be raised in a context</span>
<span class="sd">    where it would be visible to a user. (Typically it should be caught and</span>
<span class="sd">    converted to some other error, or ignored.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `_NamelistParseError`, optionally using an error message.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_NamelistParseError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_message</span> <span class="o">=</span> <span class="n">message</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an error message suitable for display.&quot;&quot;&quot;</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Error in parsing namelist&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span>


<span class="k">class</span> <span class="nc">_NamelistParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>  <span class="c1"># pylint:disable=too-few-public-methods</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to validate and read from Fortran namelist input.</span>

<span class="sd">    This is intended to be an internal helper class and should not be used</span>
<span class="sd">    directly. Use the `parse` function in this module instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">groupless</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `_NamelistParser` given text to parse in a string.&quot;&quot;&quot;</span>
        <span class="c1"># Current location within the file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Text and its size.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">)</span>
        <span class="c1"># Dictionary with group names as keys, and dictionaries of variable</span>
        <span class="c1"># name-value pairs as values. (Or a single flat dictionary if</span>
        <span class="c1"># `groupless=True`.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="c1"># Fortran allows setting a particular index of an array</span>
        <span class="c1"># such as foo(2)=&#39;k&#39;</span>
        <span class="c1"># this dict is set to that value if used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groupless</span> <span class="o">=</span> <span class="n">groupless</span>

    <span class="k">def</span> <span class="nf">_line_col_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return a string specifying the current line and column number.</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;abc\nd\nef&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._advance(5)</span>
<span class="sd">        &gt;&gt;&gt; x._line_col_string()</span>
<span class="sd">        &#39;line 2, column 1&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;line </span><span class="si">{}</span><span class="s2">, column </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_line</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_curr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the character at the current position.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the character at the next position.</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39; &#39;)._next)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If at the end of the file, we should raise _NamelistEOF. The easiest</span>
        <span class="c1"># way to do this is to just advance.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_advance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nchars</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">check_eof</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Advance the parser&#39;s current position by `nchars` characters.</span>

<span class="sd">        The `nchars` argument must be non-negative. If the end of file is</span>
<span class="sd">        reached, an exception is thrown, unless `check_eof=True` is passed. If</span>
<span class="sd">        `check_eof=True` is passed, the position is advanced past the end of the</span>
<span class="sd">        file (`self._pos == `self._len`), and a boolean is returned to signal</span>
<span class="sd">        whether or not the end of the file was reached.</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;abcd&#39;)._advance(-1)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        AssertionError: _NamelistParser attempted to &#39;advance&#39; backwards</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;abc\nd\nef&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (x._pos, x._line, x._col)</span>
<span class="sd">        (0, 1, 0)</span>
<span class="sd">        &gt;&gt;&gt; x._advance(0)</span>
<span class="sd">        &gt;&gt;&gt; (x._pos, x._line, x._col)</span>
<span class="sd">        (0, 1, 0)</span>
<span class="sd">        &gt;&gt;&gt; x._advance(2)</span>
<span class="sd">        &gt;&gt;&gt; (x._pos, x._line, x._col)</span>
<span class="sd">        (2, 1, 2)</span>
<span class="sd">        &gt;&gt;&gt; x._advance(1)</span>
<span class="sd">        &gt;&gt;&gt; (x._pos, x._line, x._col)</span>
<span class="sd">        (3, 1, 3)</span>
<span class="sd">        &gt;&gt;&gt; x._advance(1)</span>
<span class="sd">        &gt;&gt;&gt; (x._pos, x._line, x._col)</span>
<span class="sd">        (4, 2, 0)</span>
<span class="sd">        &gt;&gt;&gt; x._advance(3)</span>
<span class="sd">        &gt;&gt;&gt; (x._pos, x._line, x._col)</span>
<span class="sd">        (7, 3, 1)</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, x._advance, 1)</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39;abc\n&#39;)._advance, 4)</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;ab&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._advance(check_eof=True)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;b&#39;</span>
<span class="sd">        &gt;&gt;&gt; x._advance(check_eof=True)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">nchars</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;_NamelistParser attempted to &#39;advance&#39; backwards&quot;</span>
        <span class="n">new_pos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="n">nchars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
        <span class="n">consumed_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="p">:</span> <span class="n">new_pos</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">new_pos</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">consumed_text</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">+=</span> <span class="n">lines</span>
        <span class="c1"># If we started a new line, set self._col to be relative to the start of</span>
        <span class="c1"># the current line.</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">consumed_text</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">consumed_text</span><span class="p">)</span>
        <span class="n">end_of_file</span> <span class="o">=</span> <span class="n">new_pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
        <span class="k">if</span> <span class="n">check_eof</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">end_of_file</span>
        <span class="k">elif</span> <span class="n">end_of_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_NamelistEOF</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eat_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_initial_comment</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Advance until the next non-whitespace character.</span>

<span class="sd">        Returns a boolean representing whether anything was eaten. Note that</span>
<span class="sd">        this function also skips past new lines containing comments. Comments in</span>
<span class="sd">        the current line will be skipped if `allow_initial_comment=True` is</span>
<span class="sd">        passed in.</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39; \n a &#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._eat_whitespace()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; x._eat_whitespace()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x._advance()</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, x._eat_whitespace)</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39; \n! blah\n ! blah\n a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._eat_whitespace()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;! blah\n a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._eat_whitespace()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;!&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39; ! blah\n a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._eat_whitespace()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;!&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39; ! blah\n a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._eat_whitespace(allow_initial_comment=True)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eaten</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">comment_allowed</span> <span class="o">=</span> <span class="n">allow_initial_comment</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="n">comment_allowed</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">eaten</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
            <span class="c1"># Note the reliance on short-circuit `and` here.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">comment_allowed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eat_comment</span><span class="p">()):</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">eaten</span>

    <span class="k">def</span> <span class="nf">_eat_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;If currently positioned at a &#39;!&#39;, advance past the comment&#39;s end.</span>

<span class="sd">        Only works properly if not currently inside a comment or string. Returns</span>
<span class="sd">        a boolean representing whether anything was eaten.</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;! foo\n ! bar\na ! bazz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._eat_comment()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39; &#39;</span>
<span class="sd">        &gt;&gt;&gt; x._eat_comment()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x._eat_whitespace()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._eat_comment()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; x._advance(2)</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, x._eat_comment)</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;! foo\n&#39;)</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, x._eat_comment)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;!&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">newline_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="p">:]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newline_pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># This is the last line.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Advance to the next line.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="n">newline_pos</span><span class="p">)</span>
            <span class="c1"># Advance to the first character of the next line.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_expect_char</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise an error if the wrong character is present.</span>

<span class="sd">        Does not return anything, but raises a `_NamelistParseError` if `chars`</span>
<span class="sd">        does not contain the character at the current position.</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;ab&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_char(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._advance()</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, x._expect_char, &#39;a&#39;)</span>

<span class="sd">        &gt;&gt;&gt; x._expect_char(&#39;ab&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">chars</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">char_description</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">chars</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">char_description</span> <span class="o">=</span> <span class="s2">&quot;one of the characters in </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">chars</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">_NamelistParseError</span><span class="p">(</span>
                <span class="s2">&quot;expected </span><span class="si">{}</span><span class="s2"> but found </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">char_description</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()))</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_namelist_group_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parses and returns a namelist group name at the current position.</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;abc&#39;)._parse_namelist_group_name)</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39;&amp;abc&#39;)._parse_namelist_group_name)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;&amp;abc &#39;)._parse_namelist_group_name()</span>
<span class="sd">        &#39;abc&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;&amp;abc\n&#39;)._parse_namelist_group_name()</span>
<span class="sd">        &#39;abc&#39;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;&amp;abc/ &#39;)._parse_namelist_group_name)</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;&amp;abc= &#39;)._parse_namelist_group_name)</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;&amp; &#39;)._parse_namelist_group_name)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expect_char</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_name</span><span class="p">(</span><span class="n">allow_equals</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_equals</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parses and returns a variable name at the current position.</span>

<span class="sd">        The `allow_equals` flag controls whether &#39;=&#39; can denote the end of the</span>
<span class="sd">        variable name; if it is `False`, only white space can be used for this</span>
<span class="sd">        purpose.</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39;abc&#39;)._parse_variable_name)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;foo(2)= &#39;)._parse_variable_name()</span>
<span class="sd">        &#39;foo(2)&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;abc &#39;)._parse_variable_name()</span>
<span class="sd">        &#39;abc&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;ABC &#39;)._parse_variable_name()</span>
<span class="sd">        &#39;ABC&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;abc\n&#39;)._parse_variable_name()</span>
<span class="sd">        &#39;abc&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;abc%fred\n&#39;)._parse_variable_name()</span>
<span class="sd">        &#39;abc%fred&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;abc(2)@fred\n&#39;)._parse_variable_name()</span>
<span class="sd">        &#39;abc(2)@fred&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;abc(1:2:3)\n&#39;)._parse_variable_name()</span>
<span class="sd">        &#39;abc(1:2:3)&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;aBc=&#39;)._parse_variable_name()</span>
<span class="sd">        &#39;aBc&#39;</span>
<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        ...     _NamelistParser(&#39;abc(1,2) &#39;)._parse_variable_name()</span>
<span class="sd">        ...     raise AssertionError(&quot;_NamelistParseError not raised&quot;)</span>
<span class="sd">        ... except _NamelistParseError:</span>
<span class="sd">        ...    pass</span>
<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        ...     _NamelistParser(&#39;abc, &#39;)._parse_variable_name()</span>
<span class="sd">        ...     raise AssertionError(&quot;_NamelistParseError not raised&quot;)</span>
<span class="sd">        ... except _NamelistParseError:</span>
<span class="sd">        ...    pass</span>
<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        ...    _NamelistParser(&#39; &#39;)._parse_variable_name()</span>
<span class="sd">        ...    raise AssertionError(&quot;_NamelistParseError not raised&quot;)</span>
<span class="sd">        ... except _NamelistParseError:</span>
<span class="sd">        ...    pass</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;foo+= &#39;)._parse_variable_name()</span>
<span class="sd">        &#39;foo&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="n">separators</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">allow_equals</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">separators</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">old_pos</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;(&quot;</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">expect</span><span class="p">(</span><span class="s2">&quot;)&quot;</span> <span class="ow">in</span> <span class="n">text</span><span class="p">,</span> <span class="s2">&quot;Parsing error &quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;)&quot;</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">expect</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Parsing error &quot;</span><span class="p">)</span>

        <span class="c1"># @ is used in a namelist to put the same namelist variable in multiple groups</span>
        <span class="c1"># in the write phase, all characters in the namelist variable name after</span>
        <span class="c1"># the @ and including the @ should be removed</span>
        <span class="k">if</span> <span class="s2">&quot;%&quot;</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">text_check</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;%.+$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;@&quot;</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">text_check</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;@.+$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">text_check</span> <span class="o">=</span> <span class="n">text</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_fortran_name</span><span class="p">(</span><span class="n">text_check</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*\(.*\,.*\)&quot;</span><span class="p">,</span> <span class="n">text_check</span><span class="p">):</span>
                <span class="n">err_str</span> <span class="o">=</span> <span class="s2">&quot;Multiple dimensions not supported in CIME namelist variables </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> is not a valid variable name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">_NamelistParseError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">_parse_character_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse and return a character literal (a string).</span>

<span class="sd">        Position on return is the last character of the string; we avoid</span>
<span class="sd">        advancing past that in order to avoid potential EOF errors.</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39;&quot;abc&#39;)._parse_character_literal)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;&quot;abc&quot; &#39;)._parse_character_literal()</span>
<span class="sd">        &#39;&quot;abc&quot;&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;&#39;abc&#39; &quot;)._parse_character_literal()</span>
<span class="sd">        &quot;&#39;abc&#39;&quot;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&quot;*abc* &quot;)._parse_character_literal)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;&#39;abc&#39;&#39;def&#39; &quot;)._parse_character_literal()</span>
<span class="sd">        &quot;&#39;abc&#39;&#39;def&#39;&quot;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;&#39;abc&#39;&#39;&#39; &quot;)._parse_character_literal()</span>
<span class="sd">        &quot;&#39;abc&#39;&#39;&#39;&quot;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;&#39;&#39;&#39;abc&#39; &quot;)._parse_character_literal()</span>
<span class="sd">        &quot;&#39;&#39;&#39;abc&#39;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delimiter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span>
        <span class="n">old_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">!=</span> <span class="n">delimiter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
            <span class="c1"># Avoid end-of-file condition.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># Doubled delimiters are escaped.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span> <span class="o">==</span> <span class="n">delimiter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">old_pos</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_fortran_namelist_literal</span><span class="p">(</span><span class="s2">&quot;character&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">_NamelistParseError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid character literal&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">_parse_complex_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse and return a complex literal.</span>

<span class="sd">        Position on return is the last character of the string; we avoid</span>
<span class="sd">        advancing past that in order to avoid potential EOF errors.</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39;(1.,2.&#39;)._parse_complex_literal)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;(1.,2.) &#39;)._parse_complex_literal()</span>
<span class="sd">        &#39;(1.,2.)&#39;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&quot;(A,B) &quot;)._parse_complex_literal)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">old_pos</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_fortran_namelist_literal</span><span class="p">(</span><span class="s2">&quot;complex&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">_NamelistParseError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> is not a valid complex literal&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">_look_ahead_for_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Look ahead to see if the next whitespace character is &#39;=&#39;.</span>

<span class="sd">        The `pos` argument is the position in the text to start from while</span>
<span class="sd">        looking. This function returns a boolean.</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;=&#39;)._look_ahead_for_equals(0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;a \n=&#39;)._look_ahead_for_equals(1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;&#39;)._look_ahead_for_equals(0)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;a=&#39;)._look_ahead_for_equals(0)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">test_pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">test_pos</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">test_pos</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_look_ahead_for_plusequals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Look ahead to see if the next two non-whitespace character are &#39;+=&#39;.</span>

<span class="sd">        The `pos` argument is the position in the text to start from while</span>
<span class="sd">        looking. This function returns a boolean.</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;+=&#39;)._look_ahead_for_plusequals(0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;a \n+=&#39;)._look_ahead_for_plusequals(1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;&#39;)._look_ahead_for_plusequals(0)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;a+=&#39;)._look_ahead_for_plusequals(0)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">test_pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">test_pos</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">test_pos</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_look_ahead_for_equals</span><span class="p">(</span><span class="n">test_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_parse_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_eof_end</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parse and return a variable value at the current position.</span>

<span class="sd">        The basic strategy is this:</span>
<span class="sd">        - If a value starts with an apostrophe/quotation mark, parse it as a</span>
<span class="sd">        character value (string).</span>
<span class="sd">        - If a value starts with a left parenthesis, parse it as a complex</span>
<span class="sd">        number.</span>
<span class="sd">        - Otherwise, read until the next value separator (comma, space, newline,</span>
<span class="sd">        or slash).</span>

<span class="sd">        If the argument `allow_name=True` is passed in, we allow the possibility</span>
<span class="sd">        that the current position is at the start of the variable name in a new</span>
<span class="sd">        name-value pair. In this case, `None` is returned, and the current</span>
<span class="sd">        position remains unchanged.</span>

<span class="sd">        If the argument `allow_eof_end=True` is passed in, we allow end-of-file</span>
<span class="sd">        to mark the end of a literal.</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;&quot;abc&quot; &#39;)._parse_literal()</span>
<span class="sd">        &#39;&quot;abc&quot;&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;&#39;abc&#39; &quot;)._parse_literal()</span>
<span class="sd">        &quot;&#39;abc&#39;&quot;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39;&quot;abc&quot;&#39;)._parse_literal)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;&quot;abc&quot;&#39;)._parse_literal(allow_eof_end=True)</span>
<span class="sd">        &#39;&quot;abc&quot;&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;(1.,2.) &#39;)._parse_literal()</span>
<span class="sd">        &#39;(1.,2.)&#39;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39;(1.,2.)&#39;)._parse_literal)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;(1.,2.)&#39;)._parse_literal(allow_eof_end=True)</span>
<span class="sd">        &#39;(1.,2.)&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;5 &#39;)._parse_literal()</span>
<span class="sd">        &#39;5&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;6.9 &#39;)._parse_literal()</span>
<span class="sd">        &#39;6.9&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;inf &#39;)._parse_literal()</span>
<span class="sd">        &#39;inf&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;nan(booga) &#39;)._parse_literal()</span>
<span class="sd">        &#39;nan(booga)&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;.FLORIDA$ &#39;)._parse_literal()</span>
<span class="sd">        &#39;.FLORIDA$&#39;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;hamburger &#39;)._parse_literal)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;5,&#39;)._parse_literal()</span>
<span class="sd">        &#39;5&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;5\n&#39;)._parse_literal()</span>
<span class="sd">        &#39;5&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;5/&#39;)._parse_literal()</span>
<span class="sd">        &#39;5&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;,&#39;)._parse_literal()</span>
<span class="sd">        &#39;&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;6*5 &#39;)._parse_literal()</span>
<span class="sd">        &#39;6*5&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;6*(1., 2.) &#39;)._parse_literal()</span>
<span class="sd">        &#39;6*(1., 2.)&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;6*&quot;a&quot; &#39;)._parse_literal()</span>
<span class="sd">        &#39;6*&quot;a&quot;&#39;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&#39;6*&#39;)._parse_literal)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;6*&#39;)._parse_literal(allow_eof_end=True)</span>
<span class="sd">        &#39;6*&#39;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;foo= &#39;)._parse_literal)</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;foo+= &#39;)._parse_literal)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;5,&#39;)._parse_literal(allow_name=True)</span>
<span class="sd">        &#39;5&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;foo= &#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_literal(allow_name=True)</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;f&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;foo+= &#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_literal(allow_name=True)</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;f&#39;</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;6*foo= &#39;)._parse_literal, allow_name=True)</span>

<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&#39;6*foo+= &#39;)._parse_literal, allow_name=True)</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;foo = &#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_literal(allow_name=True)</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;f&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&#39;foo\n= &#39;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_literal(allow_name=True)</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;f&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&#39;&#39;)._parse_literal(allow_eof_end=True)</span>
<span class="sd">        &#39;&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Deal with empty input string.</span>
        <span class="k">if</span> <span class="n">allow_eof_end</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># Deal with a repeated value prefix.</span>
        <span class="n">old_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="k">if</span> <span class="n">FORTRAN_REPEAT_PREFIX_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="p">:]):</span>
            <span class="n">allow_name</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="n">check_eof</span><span class="o">=</span><span class="n">allow_eof_end</span><span class="p">):</span>
                <span class="c1"># In case the file ends with the &#39;r*&#39; form of null value.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">old_pos</span><span class="p">:]</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">old_pos</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>
        <span class="c1"># Deal with delimited literals.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">):</span>
            <span class="n">literal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_character_literal</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="n">check_eof</span><span class="o">=</span><span class="n">allow_eof_end</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">literal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
            <span class="n">literal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_complex_literal</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="n">check_eof</span><span class="o">=</span><span class="n">allow_eof_end</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">literal</span>
        <span class="c1"># Deal with non-delimited literals.</span>
        <span class="n">new_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="n">separators</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">allow_name</span><span class="p">:</span>
            <span class="n">separators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
            <span class="n">separators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">new_pos</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">new_pos</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">separators</span><span class="p">:</span>
            <span class="c1"># allow commas if they are inside ()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">new_pos</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
                <span class="n">separators</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">new_pos</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span>
                <span class="n">separators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="n">new_pos</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_eof_end</span> <span class="ow">and</span> <span class="n">new_pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
            <span class="c1"># At the end of the file, give up by throwing an EOF.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
        <span class="c1"># If `allow_name` is set, we need to check and see if the next non-blank</span>
        <span class="c1"># character is &#39;=&#39; or the next two are &#39;+=&#39;, and return `None` if so.</span>
        <span class="k">if</span> <span class="n">allow_name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_look_ahead_for_equals</span><span class="p">(</span><span class="n">new_pos</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">allow_name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_look_ahead_for_plusequals</span><span class="p">(</span><span class="n">new_pos</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">(</span><span class="n">new_pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">,</span> <span class="n">check_eof</span><span class="o">=</span><span class="n">allow_eof_end</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="n">old_pos</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">is_valid_fortran_namelist_literal</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="s2">&quot;logical&quot;</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">_NamelistParseError</span><span class="p">(</span>
                <span class="s2">&quot;expected literal value, but got </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">_expect_separator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_eof</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Advance past the current value separator.</span>

<span class="sd">        This function raises an error if we are not positioned at a valid value</span>
<span class="sd">        separator. It returns `False` if the end-of-namelist (&#39;/&#39;) was</span>
<span class="sd">        encountered, in which case this function will leave the current position</span>
<span class="sd">        at the &#39;/&#39;. This function returns `True` otherwise, and skips to the</span>
<span class="sd">        location of the next non-whitespace character.</span>

<span class="sd">        If `allow_eof=True` is passed to this function, the meanings of &#39;/&#39; and</span>
<span class="sd">        the end-of-file are reversed. That is, an exception will be raised if a</span>
<span class="sd">        &#39;/&#39; is encountered, but the end-of-file will cause `False` to be</span>
<span class="sd">        returned rather than `True`. (An end-of-file after a &#39;,&#39; will be taken</span>
<span class="sd">        to be part of the next separator, and will not cause `False` to be</span>
<span class="sd">        returned.)</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;\na&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot; a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;,a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;/a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;/&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, x._expect_separator)</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot; , a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot; / a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;/&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot; , ! Some stuff\n a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot; , ! Some stuff\n ! Other stuff\n a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;&quot;)._expect_separator(allow_eof=True)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot; &quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator(allow_eof=True)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot; ,&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._expect_separator(allow_eof=True)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot; / &quot;)</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, x._expect_separator, allow_eof=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errstring</span> <span class="o">=</span> <span class="s2">&quot;found group-terminating &#39;/&#39; in file without group names&quot;</span>
        <span class="c1"># Deal with the possibility that we are already at EOF.</span>
        <span class="k">if</span> <span class="n">allow_eof</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Must actually be at a value separator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expect_char</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">,/&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eat_whitespace</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">allow_eof</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">_NamelistParseError</span><span class="p">(</span><span class="n">errstring</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="n">_NamelistEOF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_eof</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eat_whitespace</span><span class="p">(</span><span class="n">allow_initial_comment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">_NamelistEOF</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_eof</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_parse_name_and_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_eof_end</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parse and return a variable name and values assigned to that name.</span>

<span class="sd">        The return value of this function is a tuple containing (a) the name of</span>
<span class="sd">        the variable in a string, (b) a list of the variable&#39;s values, and</span>
<span class="sd">        (c) whether or not to add the found value to existing variable. Null</span>
<span class="sd">        values are represented by the empty string.</span>

<span class="sd">        If `allow_eof_end=True`, the end of the sequence of values might come</span>
<span class="sd">        from an empty string rather than a slash. (This is used for the</span>
<span class="sd">        alternate file format in &quot;groupless&quot; mode.)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39; /&quot;)._parse_name_and_values()</span>
<span class="sd">        (&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo(3)=&#39;bar&#39; /&quot;)._parse_name_and_values()</span>
<span class="sd">        (&#39;foo(3)&#39;, [&quot;&#39;bar&#39;&quot;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo =&#39;bar&#39; /&quot;)._parse_name_and_values()</span>
<span class="sd">        (&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=\n&#39;bar&#39; /&quot;)._parse_name_and_values()</span>
<span class="sd">        (&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;], False)</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&quot;foo &#39;bar&#39; /&quot;)._parse_name_and_values)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39;,&#39;bazz&#39; /&quot;)._parse_name_and_values()</span>
<span class="sd">        (&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=,,&#39;bazz&#39;,6*/&quot;)._parse_name_and_values()</span>
<span class="sd">        (&#39;foo&#39;, [&#39;&#39;, &#39;&#39;, &quot;&#39;bazz&#39;&quot;, &#39;6*&#39;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39; &#39;bazz&#39; foo2=&#39;ban&#39;&quot;)._parse_name_and_values()</span>
<span class="sd">        (&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39; &#39;bazz&#39; foo2(2)=&#39;ban&#39;&quot;)._parse_name_and_values()</span>
<span class="sd">        (&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;], False)</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, _NamelistParser(&quot;foo= foo2=&#39;ban&#39; &quot;)._parse_name_and_values)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=,,&#39;bazz&#39;,6* &quot;)._parse_name_and_values(allow_eof_end=True)</span>
<span class="sd">        (&#39;foo&#39;, [&#39;&#39;, &#39;&#39;, &quot;&#39;bazz&#39;&quot;, &#39;6*&#39;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo(3)=&#39;bazz&#39;&quot;)._parse_name_and_values(allow_eof_end=True)</span>
<span class="sd">        (&#39;foo(3)&#39;, [&quot;&#39;bazz&#39;&quot;], False)</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistEOF, _NamelistParser(&quot;foo=&quot;)._parse_name_and_values)</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&quot;)._parse_name_and_values(allow_eof_end=True)</span>
<span class="sd">        (&#39;foo&#39;, [&#39;&#39;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo= &quot;)._parse_name_and_values(allow_eof_end=True)</span>
<span class="sd">        (&#39;foo&#39;, [&#39;&#39;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=2&quot;)._parse_name_and_values(allow_eof_end=True)</span>
<span class="sd">        (&#39;foo&#39;, [&#39;2&#39;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=1,2&quot;)._parse_name_and_values(allow_eof_end=True)</span>
<span class="sd">        (&#39;foo&#39;, [&#39;1&#39;, &#39;2&#39;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo(1:2)=1,2,3 &quot;)._parse_name_and_values(allow_eof_end=True) # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        CIMEError: ERROR: Too many values for array foo(1:2)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=1,&quot;)._parse_name_and_values(allow_eof_end=True)</span>
<span class="sd">        (&#39;foo&#39;, [&#39;1&#39;, &#39;&#39;], False)</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo+=1&quot;)._parse_name_and_values(allow_eof_end=True)</span>
<span class="sd">        (&#39;foo&#39;, [&#39;1&#39;], True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_name</span><span class="p">()</span>
        <span class="n">addto</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># This keeps track of whether += existed</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_eat_whitespace</span><span class="p">()</span>
        <span class="c1"># check to see if we have a &quot;+=&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
            <span class="n">addto</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># tell parser that we want to add to dictionary values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expect_char</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eat_whitespace</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">_NamelistEOF</span><span class="p">:</span>
            <span class="c1"># If we hit the end of file, return a name assigned to a null value.</span>
            <span class="k">if</span> <span class="n">allow_eof_end</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span> <span class="n">addto</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="c1"># Expect at least one literal, even if it&#39;s a null value.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_literal</span><span class="p">(</span><span class="n">allow_eof_end</span><span class="o">=</span><span class="n">allow_eof_end</span><span class="p">)]</span>
        <span class="c1"># While we haven&#39;t reached the end of the namelist group...</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expect_separator</span><span class="p">(</span><span class="n">allow_eof</span><span class="o">=</span><span class="n">allow_eof_end</span><span class="p">):</span>
            <span class="c1"># see if we can parse a literal (we might get a variable name)...</span>
            <span class="n">literal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_literal</span><span class="p">(</span><span class="n">allow_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_eof_end</span><span class="o">=</span><span class="n">allow_eof_end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">literal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># and if it really is a literal, add it.</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
        <span class="p">(</span><span class="n">minindex</span><span class="p">,</span> <span class="n">maxindex</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_fortran_variable_indices</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">allow_any_len</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">minindex</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">maxindex</span> <span class="o">&gt;</span> <span class="n">minindex</span> <span class="ow">or</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">maxindex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">arraylen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">maxindex</span> <span class="o">-</span> <span class="n">minindex</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">))</span>
            <span class="n">expect</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">arraylen</span><span class="p">,</span> <span class="s2">&quot;Too many values for array </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">addto</span>

    <span class="k">def</span> <span class="nf">_parse_namelist_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parse an entire namelist group, adding info to `self._settings`.</span>

<span class="sd">        This function assumes that we start at the beginning of the group name</span>
<span class="sd">        (e.g. &#39;&amp;&#39;), and will return at the end of the namelist group (&#39;/&#39;).</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group /&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {})])</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;/&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group\n foo=&#39;bar&#39;,&#39;bazz&#39;\n,, foo2=2*5\n /&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {&#39;foo&#39;: [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;, &#39;&#39;], &#39;foo2&#39;: [&#39;5&#39;, &#39;5&#39;]})])</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group\n foo=&#39;bar&#39;,&#39;bazz&#39;\n,, foo2=2*5\n /&quot;, groupless=True)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;, &#39;&#39;]), (&#39;foo2&#39;, [&#39;5&#39;, &#39;5&#39;])])</span>
<span class="sd">        &gt;&gt;&gt; x._curr()</span>
<span class="sd">        &#39;/&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group /&amp;group /&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._advance()</span>
<span class="sd">        &gt;&gt;&gt; shouldRaise(_NamelistParseError, x._parse_namelist_group)</span>

<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group foo=&#39;bar&#39;, foo=&#39;bazz&#39; /&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {&#39;foo&#39;: [&quot;&#39;bazz&#39;&quot;]})])</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group foo=&#39;bar&#39;, foo= /&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {&#39;foo&#39;: [&quot;&#39;bar&#39;&quot;]})])</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group foo=&#39;bar&#39;, foo= /&quot;, groupless=True)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group foo=&#39;bar&#39;, foo+=&#39;baz&#39; /&quot;, groupless=True)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;baz&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group foo+=&#39;bar&#39; /&quot;, groupless=True)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group foo=&#39;bar&#39;, foo+=&#39;baz&#39; /&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {&#39;foo&#39;: [&quot;&#39;bar&#39;&quot;, &quot;&#39;baz&#39;&quot;]})])</span>
<span class="sd">        &gt;&gt;&gt; x = _NamelistParser(&quot;&amp;group foo+=&#39;bar&#39; /&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x._parse_namelist_group()</span>
<span class="sd">        &gt;&gt;&gt; x._settings</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {&#39;foo&#39;: [&quot;&#39;bar&#39;&quot;]})])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">group_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_namelist_group_name</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupless</span><span class="p">:</span>
            <span class="c1"># Make sure that this is the first time we&#39;ve seen this group.</span>
            <span class="k">if</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">_NamelistParseError</span><span class="p">(</span>
                    <span class="s2">&quot;Namelist group </span><span class="si">{!r}</span><span class="s2"> encountered twice.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">group_name</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eat_whitespace</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">addto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_name_and_values</span><span class="p">()</span>
            <span class="n">dsettings</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupless</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">:</span>
                    <span class="n">dsettings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">addto</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">values</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">addto</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">merge_literal_lists</span><span class="p">(</span><span class="n">dsettings</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">dsettings</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">addto</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">values</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">addto</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">merge_literal_lists</span><span class="p">(</span><span class="n">dsettings</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                <span class="n">group</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">parse_namelist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parse the contents of an entire namelist file.</span>

<span class="sd">        Returned information is a dictionary of dictionaries, mapping variables</span>
<span class="sd">        first by namelist group name, then by variable name.</span>

<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;&quot;).parse_namelist()</span>
<span class="sd">        OrderedDict()</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot; \n!Comment&quot;).parse_namelist()</span>
<span class="sd">        OrderedDict()</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot; &amp;group /&quot;).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {})])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;! Comment \n &amp;group /! Comment\n &quot;).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {})])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;! Comment \n &amp;group /! Comment &quot;).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;group&#39;, {})])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;&amp;group1\n foo=&#39;bar&#39;,&#39;bazz&#39;\n,, foo2=2*5\n / &amp;group2 /&quot;).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;group1&#39;, {&#39;foo&#39;: [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;, &#39;&#39;], &#39;foo2&#39;: [&#39;5&#39;, &#39;5&#39;]}), (&#39;group2&#39;, {})])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;!blah \n foo=&#39;bar&#39;,&#39;bazz&#39;\n,, foo2=2*5\n &quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;, &#39;&#39;]), (&#39;foo2&#39;, [&#39;2*5&#39;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;!blah \n foo=&#39;bar&#39;,&#39;bazz&#39;\n,, foo2=2*5,6\n &quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;, &#39;&#39;]), (&#39;foo2&#39;, [&#39;2*5&#39;, &#39;6&#39;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;!blah \n foo=&#39;bar&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39;, foo(3)=&#39;bazz&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;]), (&#39;foo(3)&#39;, [&quot;&#39;bazz&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo(2)=&#39;bar&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo(2)&#39;, [&quot;&#39;bar&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo(2)=&#39;bar&#39;, foo(3)=&#39;bazz&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo(2)&#39;, [&quot;&#39;bar&#39;&quot;]), (&#39;foo(3)&#39;, [&quot;&#39;bazz&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39;, foo=&#39;bazz&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bazz&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39;\n foo+=&#39;bazz&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39;, foo=&#39;bazz&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bazz&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39;, foo=&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo=&#39;bar&#39;, &#39;bazz&#39;\n foo+=&#39;ban&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;, &quot;&#39;bazz&#39;&quot;, &quot;&#39;ban&#39;&quot;])])</span>
<span class="sd">        &gt;&gt;&gt; _NamelistParser(&quot;foo+=&#39;bar&#39;&quot;, groupless=True).parse_namelist()</span>
<span class="sd">        OrderedDict([(&#39;foo&#39;, [&quot;&#39;bar&#39;&quot;])])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return empty dictionary for empty files.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span>
        <span class="c1"># Remove initial whitespace and comments, and return empty dictionary if</span>
        <span class="c1"># that&#39;s all we have.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eat_whitespace</span><span class="p">(</span><span class="n">allow_initial_comment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">_NamelistEOF</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span>
        <span class="c1"># Handle case with no namelist groups.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupless</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;&amp;&quot;</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">addto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_name_and_values</span><span class="p">(</span><span class="n">allow_eof_end</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">addto</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">values</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="n">merge_literal_lists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">values</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span>
        <span class="c1"># Loop over namelist groups in the file.</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_namelist_group</span><span class="p">()</span>
            <span class="c1"># After each group, try to move forward to the next one. If we run</span>
            <span class="c1"># out of text, return what we&#39;ve found.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eat_whitespace</span><span class="p">(</span><span class="n">allow_initial_comment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">_NamelistEOF</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017, U.S. National Science Foundation and U.S. Department of Energy.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
     
<script>var version_json_loc = "../../../../versions.json";</script>


</footer>
        </div>
      </div>
    </section>
  </div>
  

  <script type="text/javascript">
    let baseUriRegex = /(.*\/cime)\/.*/g;
    let parsedUri = baseUriRegex.exec(document.baseURI);

    if (parsedUri != null && parsedUri.length == 2) {
      let baseUri = parsedUri[1];

      $.get(`${baseUri}/versions/versions.json`, function(data) {
        let versionElement = $("#versions");

        Object.keys(data).forEach(function(key) {
          let value = data[key];

          let item = `<dd><a href="${baseUri}/versions/${key}/html/">${value}</a></dd>`

          versionElement.append(item);
        });
      });
    }
  </script>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: master
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      
      <dl id="versions">
        <dt>Versions</dt>
      </dl>
      
      
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>