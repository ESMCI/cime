#!/usr/bin/env perl
#-----------------------------------------------------------------------------------------------
#
# xmlchange
#
# This utility allows the user to change a env_*xml file via a commandline interface.
#
# The command is echoed to the CaseStatus file, unless -noecho is given. The
# purpose of this echoing is to provide a "paper trail" of changes made by the
# user, so calls to xmlchange by the cime scripts that are part of the normal case
# setup/build process should generally use -noecho.
#
#-----------------------------------------------------------------------------------------------

use strict;
#use warnings;
#use diagnostics;
use Cwd qw( getcwd abs_path chdir);
use English;
use Getopt::Long;
use IO::File;
use IO::Handle;
use File::Copy;
use XML::LibXML;

#-----------------------------------------------------------------------------------------------
sub usage {
    die <<EOF;
SYNOPSIS
     xmlchange [options] <listofsettings>
DESCRIPTION
     allows user to modify an xml file and perform consistency checks where appropriate

OPTIONS
     User supplied values are denoted in angle brackets (<>).  Any value that contains
     white-space must be quoted.  Long option names may be supplied with either single
     or double leading dashes.  A consequence of this is that single letter options may
     NOT be bundled.
REQUIRED OPTIONS

   Either provide ALL of the following options to modify a single variable...

     -file <name>         xml file to modify 
                          NOTE: this is no longer utilized - but is there for backwards compatibility
     -id <name>           xml variable id
     -val <name> 	  xml new value for variable id

   Or provide the settings in a comma-delimited list form as: <listofsettings>

      var=value,var2=value2

   To set one or more variables without having to know the filename a variable is in.

   NOTE: NO-Whitespace. No spaces between commas, or in values unless you quote the
         entire string so the shell recognizes it as one thing. Also values can NOT
         contain the symbols "=" or ",".

OPTIONAL
     -append [or -a]      append value to the end of existing value
     -help [or -h]        Print usage to STDOUT.
     -noecho              Do NOT echo command to CaseStatus file
     -silent [or -s]      Turns on silent mode - only fatal messages issued.
     -verbose [or -v]     Turn on verbose echoing of settings.
     -warn [or -w]        Warn and abort if you are overwriting data that is not blank

NOTE:
     You can NOT use both the warn and append modes at the same time.
EOF
}

#-----------------------------------------------------------------------------------------------
if ($#ARGV == -1) {
    print "ERROR xmlchange: no arguments sent in\n";
    usage();
}

# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.
*STDOUT->autoflush();                  

my $xml = XML::LibXML->new( no_blanks => 1)->parse_file("env_case.xml"); 
my @nodes = $xml->findnodes(".//entry[\@id=\"CIMEROOT\"]"); 
my $cimeroot = $nodes[0]->getAttribute('value');

unshift @INC, "$cimeroot/utils/perl5lib";
require Config::SetupTools;

# Parse command-line options.
my @saved_argv = @ARGV;

my %opts = (
    file=>undef,
    id=>undef,
    val=>undef,
    );

GetOptions(
    "a|append"   => \$opts{'append'},
    "file=s"     => \$opts{'file'},
    "id=s"       => \$opts{'id'},
    "val=s"      => \$opts{'val'},
    "h|help"     => \$opts{'help'},
    "noecho"     => \$opts{'noecho'},
    "s|silent"   => \$opts{'silent'},
    "v|verbose"  => \$opts{'verbose'},
    "w|warn"     => \$opts{'warn'},
)  or usage();

# Give usage message.
usage() if $opts{'help'};

# Get the list form if anything else is set
my $settinglist = shift(@ARGV);

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR xmlchange: unrecognized arguments: @ARGV\n";
    print "A list of ID's needs to be comma-delimited with NO-WHITESPACE!\n";
    usage();
}

# Check for manditory case input if not just listing valid values
my %idlist;
if ( ! defined($settinglist) ) {
   foreach my $item ( "file", "id", "val" ) 
   {
      if ( ! defined($opts{$item}) ) {
         print "ERROR xmlchange : Must provide $item as input argument \n";
         usage();
      }
   }
   $idlist{$opts{'id'}} = $opts{'val'};
} else {
   foreach my $varval ( split( /,/, $settinglist ) ) {
      if ( $varval =~ /^([a-zA-Z0-9_]+)=([^,=]+)$/ ) {
         if ( defined($idlist{$1}) ) {
            print "ERROR: variable $1 was already set once in the settings list: $settinglist\n";
         }
         $idlist{$1} = $2;
      } else {
         print "ERROR xmlchange : variable = value setting is NOT recognized: $varval\n";
         die "Should be of the form: variable = value\n";
      }
   }
}

# If filename is input as option - check that it is supported
my @filenames = qw(env_run.xml env_build.xml env_case.xml env_mach_pes.xml);
if ( ! defined($settinglist) ) {
   push (@filenames, $opts{'file'});
   my $status = 0;
   foreach my $filename (@filenames) 
   {
       if ($opts{'file'} eq $filename) {
	   $status = 1;
	   last;
       }
   }
   if ($status != 1) {
       print "** $opts{'file'} is not an acceptable file to modify *** \n";
       print "*** acceptable files are @filenames *** \n";
       print "*** Note: env_archive.xml can be modified manually and checked with xmllint. *** \n";
       print " *** See st_archive --help for details *** \n";
       die;
   }
}

# Define 3 print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (default)
# 2 - verbose
my $print = 1;
if ($opts{'silent'})  { $print = 0; }
if ($opts{'verbose'}) { $print = 2; }
if ($opts{'append'} && $opts{'warn'} ) {
    die "warn and append modes can NOT both be set\n";
}
my $eol = "\n";

#-----------------------------------------------------------------------------------------------
# Determine the env_xxx.xml file for each required xmlchange variable
# store these in the hash %id_file
#-----------------------------------------------------------------------------------------------

my (%id_file, $type, $value, $valid_values, $is_list_value);
foreach my $id ( keys(%idlist) )  
{
    foreach my $file (@filenames) 
    {
	# Loop over all nodes in the file
	my $xml_file = XML::LibXML->new( no_blanks => 1)->parse_file($file); 
	foreach my $node ($xml_file->findnodes(".//entry[\@id=\"$id\"]")) 
	{
	    # Store this in %id_file hash - this will be used below
	    $id_file{$id} = $file;

	    # Do error checking for requested change
	    $value = $node->getAttribute('value');
	    foreach my $childnode ($node->childNodes()) 
	    {
		if ($childnode->nodeName() eq 'type') {
		    $type = $childnode->textContent();
		}
		if ($childnode->nodeName() eq 'valid_values') {
		    $valid_values = $childnode->textContent();
		}
		if ($childnode->nodeName() eq 'list') {
		    $is_list_value = $childnode->textContent();
		}
	    }

	    # Determine if requested change is a value
	    # Only do this if the variable does not start with $
	    # TODO - must generalize this check - so you substitute first then check
	    # for valid values even if the value starts with $
	    # Will die in is_valid_values if the check fails
	    if ($value !~ m/^$/) {
		my $newvalue = $idlist{$id};
		SetupTools::is_valid_value($id, $newvalue, $valid_values, $is_list_value);
	    }

	    # If append mode is on - check that variable is of the character type
	    if ($opts{'append'}) {
		if ( $type ne 'char') {
		    die "ERROR xmlchange: Append mode can ONLY work on character type values.\n";
		}
	    }

	    # If warn mode is on, abort if data is set to something other than missing values
	    if ($opts{'warn'}) {
		if ( $type ne 'char') {
		    if ( ($value !~ m/^\s*$/) && ($value !~ m/UNSET/i) ) { 
			die "ERROR xmlchange: Variable $id is already set to $value.\n";
		    }
		} elsif ( $value != -99 && $value != -999 && $value != -999.99 ) { 
		    die "ERROR xmlchange : Variable $id is already set to $value.\n";
		}
	    }
	    last;
	}
    }
    if (! $id_file{$id}) {
	die "ERROR xmlchange: variable $id is not a valid name \n";
    }
}

#-----------------------------------------------------------------------------------------------
# Now overwrite all the necessary files that contain variables that must be modified
# Before overwriting the file, make a backup copy in case  there are file system problems, 
# this way the original xml file does not get corrupted.
#-----------------------------------------------------------------------------------------------

foreach my $file (values (%id_file)) 
{
    # Create backup file
    my $backupfile = "$file.bak";
    copy($file, $backupfile) or die "A problem occurred copying $file to $backupfile, reason was $!";
    
    # Write out the file header
    my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($file); 

    my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";
    print $fh "<?xml version=\"1.0\"?> \n";
    print $fh "\n";
    print $fh "<config_definition> \n";
    print $fh "\n";

    my @nodes_header = $xml->findnodes(".//header");
    if ($#nodes_header == 0)  {
	my $header_text = $nodes_header[0]->textContent();
	print $fh "<header>";
	print $fh "$header_text";
	print $fh "</header> "; 
    }

    # Write out the groups contained in the file
    print $fh "\n\n";
    print $fh "<groups>\n";   	    
    foreach my $node ($xml->findnodes(".//groups/*")) 
    {
	my $group = $node->textContent();
	print $fh "   <group>$group</group> \n"; 
    }
    print $fh "</groups>\n";   	    
    print $fh "\n";

    # Loop over each file variable, modify if needed, then write it out
    foreach my $node ($xml->findnodes(".//entry")) 
    {
	my $name  = $node->getAttribute('id');
	my $value = $node->getAttribute('value');
	$value =~ s/'/&apos;/g;
	$value =~ s/\</&lt;/g;
	$value =~ s/\</&gt;/g;

	my ($group, $valid_values, $type, $desc, $is_list_value);
	foreach my $childnode ($node->childNodes()) 
	{
	    # Determine all node properties other than value
	    if ($childnode->nodeName() eq 'desc') {
		$desc = $childnode->textContent();
		$desc =~ s/^\n//;
		$desc =~ s/\n$//;
		$desc =~ s/\r//;
		$desc =~ s/^ *//;
		chomp $desc;
	    }
	    if ($childnode->nodeName() eq 'type') {
		$type = $childnode->textContent();
	    }
	    if ($childnode->nodeName() eq 'valid_values') {
		$valid_values = $childnode->textContent();
	    }
	    if ($childnode->nodeName() eq 'group') {
		$group = $childnode->textContent();
	    }
	    if ($childnode->nodeName() eq 'list') {
		$is_list_value = $childnode->textContent();
	    }

	}

	# Loop over all entries in the file
	foreach my $id ( keys(%idlist) ) 
	{
	    # Make a change to the value if requested
	    if ($id eq $name) {
		my $id_value = $idlist{$id};
		my $newval   = $id_value;
		if ($opts{'append'}) {
		    # Append new value on the end of old only if old NOT unset
		    if ( ($value !~ m/^\s*$/) && ($value !~ m/UNSET/i) ) { 
			$newval = "$value $id_value";
		    }
		}		    
		$newval =~ s/'/&apos;/g;
		$newval =~ s/\</&lt;/g;
		$newval =~ s/\</&gt;/g;
		$value  = $newval;
	    }
	} 

	# Write out the entry
	write_xml_entry($fh, $name, $value, $type, $valid_values, $desc, $group, $is_list_value);
    }

    # print out the tail of the fail
    print $fh "\n";
    print $fh "</config_definition> \n";

    # Before finishing, remove the backup files.  
    unlink($backupfile) or warn "unable to link $backupfile, $!";
}

if (! $opts{'noecho'}) {
   echo_command_to_CaseStatus();
}

if ($print>=2) { print "xmlchange done.\n"; }
exit;

#-----------------------------------------------------------------------------------------------
sub echo_command_to_CaseStatus {
   # Echoes this xmlchange command to the CaseStatus file

    my $cwd = getcwd();                    # current working directory

   if (-f "./CaseStatus") {
      open my $CS, ">>", "$cwd/CaseStatus";
      print $CS "<command>xmlchange @saved_argv</command>\n";
      close $CS;
   }
   else {
      warn "WARNING: No CaseStatus file found; this xmlchange command has been executed, but not recorded in the CaseStatus file\n";
   }
}   

#-----------------------------------------------------------------------------------------------
sub write_xml_entry
{
    my ($fh, $id, $value, $type, $valid_values, $desc, $group, $is_list_value) = @_;

    $value =~ s/'/&apos;/g;
    $value =~ s/\</&lt;/g;
    $value =~ s/\</&gt;/g;
    
    $desc =~ s/^\n//;
    $desc =~ s/\n$//;
    $desc =~ s/^ *//;
    $desc =~ s/ *$//g;
    chomp $desc;
    
    print $fh "\n";
    print $fh "<entry id=\"$id\"  value=\"$value\">\n";   	    
    print $fh "  <type>$type</type> \n"; 
    if ($valid_values  ne '') {print $fh "  <valid_values>$valid_values</valid_values> \n";}
    if ($is_list_value ne '') {print $fh "  <list>$is_list_value</list> \n";}
    print $fh "  <group>$group</group> \n"; 
    print $fh "  <desc>$desc</desc> \n";
    print $fh "</entry> \n";
}

