#!/usr/bin/env perl

#-----------------------------------------------------------------------------------------------
# xmlquery
#
# This utility allows the CIME user to view a field in a env_*xml file via a commandline interface.
#-----------------------------------------------------------------------------------------------

use strict;
use English;
use Cwd qw( getcwd abs_path chdir);
use Getopt::Long;
use IO::File;
use IO::Handle;
use XML::LibXML;

#-----------------------------------------------------------------------------------------------
sub usage 
{
    die <<EOF;
SYNOPSIS
     xmlquery id [options]
DESCRIPTION
     allows user to view a field in a env*.xml file
REQUIRED INPUT
     id                   Can have one of three values
                          (1) Variable name of the field to view - for example 
			      > xmlquery CASE [options]
                          (2) A comma-seperated list of ids to query [NO-WHITESPACE] - for example
                              > xmlquery CASE,GRID,MACH [options]
                          (3) Set to list ALL variables - for example
                              > xmlquery list [options]
OPTIONS
     User supplied values are denoted in angle brackets (<>).  Any value that contains
     white-space must be quoted.  Long option names may be supplied with either single
     or double leading dashes.  A consequence of this is that single letter options may
     NOT be bundled.

     -fileonly            Only print the filename that the field is in.
     -valonly             Only print the value of the field.
     -value               Only print the value of the field without any equal or identifier.
     -noexpandxml         Do not expand any xml variables that the value is dependent on.
     -help [or -h]        Print usage to STDOUT.
     -verbose [or -v]     Turn on verbose echoing of what xmlquery is doing.

EOF
}

#-----------------------------------------------------------------------------------------------
if ($#ARGV == -1) {
    print "ERROR: no arguments sent in -- id  name is REQUIRED\n";
    usage();
}

# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.
*STDOUT->autoflush();                  

# Set the directory that contains the CIME configuration scripts.  If the create_newcase command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) { 
    $cfgdir = abs_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

# First determine CIMEROOT

my $xml = XML::LibXML->new( no_blanks => 1)->parse_file("env_case.xml"); 
my @nodes = $xml->findnodes(".//entry[\@id=\"CIMEROOT\"]"); 
my $cimeroot = $nodes[0]->getAttribute('value');

unshift @INC, "$cimeroot/utils/perl5lib";
require Config::SetupTools;

# Parse command-line options.
my %opts = (
    fileonly		=>0,
    valonly		=>0,
    value	        =>0,
    noexpandxml	        =>0,
    help		=>0,
    listall		=>0,
    verbose		=>0,
    );

GetOptions(
    "fileonly"     => \$opts{'fileonly'},
    "valonly"      => \$opts{'valonly'},
    "value"        => \$opts{'value'},
    "noexpandxml"  => \$opts{'noexpandxml'},
    "h|help"       => \$opts{'help'},
    "v|verbose"    => \$opts{'verbose'},
)  or usage();

# Give usage message.
usage() if $opts{'help'};

# Error checks on arguments
if ($opts{'value'} && $opts{'fileonly'} ) {
    die "value and fileonly modes can NOT both be set\n";
}
if ($opts{'valonly'} && $opts{'fileonly'} ) {
    die "valonly and fileonly modes can NOT both be set\n";
}

# Determine the required input "id"
my $idlist = shift( @ARGV );

# Check for unparsed arguments
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    print "A list of ID's needs to be comma-delimited with NO-WHITESPACE!\n";
    usage();
}

# *** Print out requested variables - first get requested id from anything left over***
if ( $idlist eq "list" ) {
    _listall();
} else {
    _listids($idlist)
}

if ($opts{'verbose'}) { print "xmlchange completed successfully.\n"; }
exit;

#-----------------------------------------------------------------------------------------------
#                               Private Routines
#-----------------------------------------------------------------------------------------------
sub _listids
{
    my ($idlist) = @_; 

    # First create the hash %xmlvars and %xmlfile in order to call
    # expand_xml_var if needed
    my %xmlvars;
    my %xmlfile;
    my @files = ('env_build.xml', 'env_case.xml', 'env_mach_pes.xml', 
		 'env_mach_specific.xml', 'env_run.xml', 'env_test.xml'); 
    foreach my $file (@files) {
	if (-f $file) {
	    my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($file);
	    my @nodes = $xml->findnodes(".//entry");
	    if (@nodes) {
		foreach my $node (@nodes) {
		    my $id    = $node->getAttribute('id');
		    my $value = $node->getAttribute('value');
		    $xmlvars{$id} = $value;
		    $xmlfile{$id} = $file;
		}
	    }
	}
    }

    # Now print out the values of the requested ids
    my @ids = split( /,/, $idlist );
    foreach my $id ( @ids ) {
	my $file  = $xmlfile{$id};
	my $value = $xmlvars{$id};
	$value =~ s/&apos;/'/g;
	$value =~ s/&lt;/\</g;

	unless (defined($file) ) { 
	    if ( $opts{'value'} ) {
		exit(1);
	    } else {
		die "ERROR xmlquery: id $id not found in any of the xml files: @files \n"; 
	    }
	}
	if ( $opts{'noexpandxml'} ) {
	    # do nothing
	} else {
	    $value = SetupTools::expand_xml_var( $value, \%xmlvars );
	}
	if ( $opts{'valonly'} ) {
	    print "$id $value \n";
	} elsif ( $opts{'fileonly'} ) {
	    print "$file: $id \n";
	} elsif ( $opts{'value'} ) {
	    print "$value";
	} else {
	    print "$file: $id $value \n";
	}	      
    }
}

#-----------------------------------------------------------------------------------------------
sub _listall
{
    # First create the hash %xmlvars and %xmlfile in order to call
    # expand_xml_var if needed
    my %xmlvars;
    my %xmlfile;
    my @ids;
    my @files = glob( "env_*.xml" );

    foreach my $file (@files) {
	my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($file);
	my @nodes = $xml->findnodes(".//entry");
	if (@nodes) {
	    foreach my $node (@nodes) {
		my $id    = $node->getAttribute('id');
		my $value = $node->getAttribute('value');
		push (@ids, $id);
		$xmlvars{$id} = $value;
		$xmlfile{$id}  = $file;
	    }
	}
    }

    # Now print out the values of all ids
    foreach my $id ( @ids ) {
	my $file  = $xmlfile{$id};
	my $value = $xmlvars{$id};
	$value =~ s/&apos;/'/g;
	$value =~ s/&lt;/\</g;
	if ( $opts{'noexpandxml'} ) {
	    # do nothing
	} else {
	    $value = SetupTools::expand_xml_var( $value, \%xmlvars );
	}
	if ( $opts{'valonly'}  ) {
	    print "$id = $value \n";
	} elsif ( $opts{'fileonly'} ) {
	    print "$file: $id \n";
	} else {
	    print "$file: $id $value \n";
	}
    }
}
