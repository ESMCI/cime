#!/usr/bin/env perl
#-----------------------------------------------------------------------------------------------
#
# create_clone
#
#-----------------------------------------------------------------------------------------------

use strict;
#use warnings;
#use diagnostics;

use Cwd qw( getcwd abs_path chdir);
use English;
use Getopt::Long;
use IO::File;
use IO::Handle;
use Data::Dumper;

#-----------------------------------------------------------------------------------------------
# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.
*STDOUT->autoflush();                  

if ($#ARGV == -1) {
    print "Invoke create_clone -help [or -h] for usage\n";
    exit;
}
#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;
SYNOPSIS
     create_clone [options]
OPTIONS
     User supplied values are denoted in angle brackets (<>).  Any value that contains
     white-space must be quoted.  Long option names may be supplied with either single
     or double leading dashes.  A consequence of this is that single letter options may
     NOT be bundled.

     -help [or -h]        Print usage to STDOUT.
     -case <caseroot>     Specify the new case directory.
     -clone <cloneroot>   Specify the case to be cloned.
     -mach_dir            Optional location of machines directory
     -project <name>      Specify a project id for the case (optional)
                          default: user-specified environment variable PROJECT or ACCOUNT
                          or read from ~/.cesm_proj or ~/.ccsm_proj
     -silent [or -s]      Turns on silent mode - only fatal messages issued.
     -verbose [or -v]     Turn on verbose echoing of settings.
EOF
}

#-----------------------------------------------------------------------------------------------
# Parse command-line options.
my %opts = (
	    );
GetOptions(
    "h|help"                    => \$opts{'help'},
    "case=s"                    => \$opts{'case'},
    "clone=s"                   => \$opts{'clone'},
    "mach_dir=s"                => \$opts{'mach_dir'},
    "project=s"                 => \$opts{'project'},
    "s|silent"                  => \$opts{'silent'},
    "v|verbose"                 => \$opts{'verbose'},
)  or usage();

# Give usage message.
usage() if $opts{'help'};

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

# Check for manditory case input if not just listing valid values
my $case;
my $clone;
my $caseroot;
my $cloneroot;
my $project;

# Check for manditory case input
if ($opts{'case'}) {
    $case = $opts{'case'};
} else {
    die "Must provide case as input argument \n";
}
$caseroot = abs_path("$case");
if (-d $caseroot) {
    die "New caseroot directory $caseroot already exists \n";
}
my @dirs = split "/", $caseroot, -1; 
my $num = scalar @dirs;
$case = @dirs[$num-1];

# Check for manditory clone input
if ($opts{'clone'}) {
    $clone = $opts{'clone'};
} else {
    die "Must provide clone as input argument \n";
}
$cloneroot = abs_path("$clone");
(-d "$cloneroot")  or  die <<"EOF";
** Cannot find cloneroot directory \"$cloneroot\" **
EOF
my @dirs = split "/", $cloneroot, -1; 
my $num = scalar @dirs;
$clone = @dirs[$num-1];

# Define 3 print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (default)
# 2 - verbose
my $print = 1;
if ($opts{'silent'})  { $print = 0; }
if ($opts{'verbose'}) { $print = 2; }
my $eol = "\n";

#-----------------------------------------------------------------------------------------------
# Obtain necessary variables from $cloneroot
chdir ("$cloneroot");
my $cimeroot  = `./xmlquery CIMEROOT -value`;
my $machdir   = `./xmlquery MACHDIR  -value`;
my $mach      = `./xmlquery MACH     -value`;

# Update paths that Perl searches for modules
my @dirs = ("$cimeroot/utils/perl5lib");
unshift @INC, @dirs;
require Project::ProjectTools;
require Config::SetupTools;
require Batch::BatchMaker;

#-----------------------------------------------------------------------------------------------
# Create the case directory tree utilizing the clone tree 
my $sysmod;

# Create $caseroot directories 
$sysmod = "mkdir -p $caseroot"; 
system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "cp -rp $cloneroot/* $caseroot"; 
system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

# Remove unwanted files from $cloneroot
# Note - script files are named using the first 12-15 chars of $clone and we want to remove those as well
$sysmod = "rm -rf $caseroot/Buildconf/*"  ; system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "rm -rf $caseroot/CaseDocs/*"   ; system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "rm -rf $caseroot/LockedFiles/*"; system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "rm -rf $caseroot/logs/*"       ; system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "rm -rf $caseroot/timing/*"     ; system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "rm -rf $caseroot/TestStatus*"  ; system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
my $clonesubname = substr($clone,0,12);
$sysmod = "rm -f $caseroot/$clonesubname*"; 
system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
$sysmod = "rm -f $caseroot/*~";
system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

# Change directory to be $caseroot
chdir $caseroot;

# Obtain variables needed below
my $username  = "$ENV{'USER'}"; 
$sysmod = "./xmlchange USER=$username"			; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
$sysmod = "./xmlchange CASE=$case"			; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
$sysmod = "./xmlchange CASEROOT=$caseroot"		; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
$sysmod = "./xmlchange CASEBUILD=$caseroot/Buildconf"	; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
$sysmod = "./xmlchange CASETOOLS=$caseroot/Tools"	; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
$sysmod = "./xmlchange BUILD_COMPLETE=FALSE"		; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
$sysmod = "./xmlchange CONTINUE_RUN=FALSE"		; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
$sysmod = "./xmlchange RESUBMIT=0"			; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
if ($opts{'mach_dir'}) {
    $sysmod = "./xmlchange MACHIDR=$opts{'mach_dir'}"   ; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
}

# --- Set project id 
# Note: we do not just copy this from the clone because it seems likely that
# users will want to change this sometimes, especially when cloning another
# user's case. However, note that, if a project is not given, the fallback will
# be to copy it from the clone, just like other xml variables are copied. For
# that reason, we do not call check_project_required_but_unset.

# Check for optional project; if not given, see if we can find a project to use
if ($opts{'project'}) {
    $project = $opts{'project'};
} else {
    $project = ProjectTools::find_project();
}
my $set_project = ProjectTools::set_project($project);
if ($set_project) {
    $sysmod = "xmlchange PROJECT=$project"; system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
} 

# Copy env_case.xml in locked files
$sysmod = "cp $caseroot/env_case.xml $caseroot/LockedFiles/env_case.xml.locked";
system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
print "Locking file $caseroot/env_case.xml \n";

#-----------------------------------------------------------------------------------------------
# Create batch script
$sysmod = "./case_setup"; 
system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

# --- Print output ---
my $compset = `./xmlquery COMPSET -value`;
print "Successfully created new case\n   $caseroot\nfrom clone case\n   $cloneroot\n";
exit(0);



