!===================================================
! DO NOT EDIT THIS FILE, it was generated using genf90/src/genf90/genf90.pl 
! Any changes you make to this file may be lost
!===================================================
#define __PIO_FILE__ 'piodarray'
!>
!! @file
!! @brief Read and write routines for decomposed data.
!<
module piodarray
  use pio_types, only : file_desc_t, io_desc_t, var_desc_t
  use pio_kinds, only : i4, r4, r8, pio_offset_kind
  use pio_support, only : piodie
  use iso_c_binding
#ifdef TIMING
  use perf_mod, only : t_startf, t_stopf   !_EXTERNAL
#endif
  implicit none

  private
  public :: pio_read_darray, pio_write_darray, pio_set_buffer_size_limit


!>
!! @defgroup PIO_write_darray PIO_write_darray
!! @brief The overloaded PIO_write_darray writes a distributed array to disk.
!<
# 24 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  interface PIO_write_darray
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_1d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_2d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_3d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_4d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_5d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_6d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_7d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_1d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_2d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_3d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_4d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_5d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_6d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_7d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_1d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_2d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_3d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_4d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_5d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_6d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_7d_double
! TYPE real,int,double
     module procedure write_darray_multi_1d_real
! TYPE real,int,double
     module procedure write_darray_multi_1d_int
! TYPE real,int,double
     module procedure write_darray_multi_1d_double
  end interface


!>
!! @defgroup PIO_read_darray PIO_read_darray
!! @brief The overloaded PIO_read_darray function reads a distributed array from disk.
!<
# 37 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  interface PIO_read_darray
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_1d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_2d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_3d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_4d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_5d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_6d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_7d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_1d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_2d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_3d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_4d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_5d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_6d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_7d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_1d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_2d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_3d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_4d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_5d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_6d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_7d_double
  end interface


  character(len=*), parameter, private  :: modName='piodarray'

#ifdef MEMCHK
integer :: msize, rss, mshare, mtext, mstack, lastrss=0
#endif

# 50 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
interface
# 51 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
   integer(C_INT) function PIOc_write_darray(ncid, vid, ioid, arraylen, array, fillvalue) &
        bind(C,name="PIOc_write_darray")
     use iso_c_binding
     integer(C_INT), value :: ncid
     integer(C_INT), value :: vid
     integer(C_INT), value :: ioid
     integer(C_SIZE_T), value :: arraylen
     type(c_ptr), value :: array
     type(C_PTR), value :: fillvalue
# 60 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
   end function PIOc_write_darray
end interface

# 63 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
interface
# 64 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
   integer(C_INT) function PIOc_write_darray_multi(ncid, vid, ioid, nvars, arraylen, array, fillvalue) &
        bind(C,name="PIOc_write_darray_multi")
     use iso_c_binding
     integer(C_INT), value :: ncid
     integer(C_INT) :: vid(nvars)
     integer(C_INT), value :: ioid
     integer(C_INT), value :: nvars
     integer(C_SIZE_T), value :: arraylen
     type(c_ptr), value :: array
     type(C_PTR), value :: fillvalue
# 74 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
   end function PIOc_write_darray_multi
end interface

# 77 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
interface
# 78 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
   integer(C_INT) function PIOc_read_darray(ncid, vid, ioid, arraylen, array) &
        bind(C,name="PIOc_read_darray")
     use iso_c_binding
     integer(C_INT), value :: ncid
     integer(C_INT), value :: vid
     integer(C_INT), value :: ioid
     integer(C_SIZE_T), value :: arraylen
     type(C_PTR), value :: array
# 86 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
   end function PIOc_read_darray
end interface


# 90 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
contains

# 92 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine pio_set_buffer_size_limit(limit)
    integer(PIO_OFFSET_KIND), intent(in) :: limit
    integer(PIO_OFFSET_KIND) :: oldval
# 95 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
    interface
# 96 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
       integer(C_LONG_LONG) function PIOc_set_buffer_size_limit(limit) &
            bind(C,name="PIOc_set_buffer_size_limit")
         use iso_c_binding
         integer(C_LONG_LONG), value :: limit
# 100 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
       end function PIOc_set_buffer_size_limit
    end interface
    if(limit<0) then
       call piodie(__PIO_FILE__,__LINE__,' bad value to buffer_size_limit: ',int(limit))
    end if
    oldval = PIOc_set_buffer_size_limit(limit)

# 107 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine pio_set_buffer_size_limit

! TYPE real,int,double
# 110 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_1d_cinterface_real (File,varDesc,ioDesc, arraylen, array, iostat, fillval)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Writes a 2-d slab of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), dimension(*), target, intent(in) ::  &
         array                 ! array to be written

    real(r4), optional, target, intent(in) :: fillval    ! rearrange receiver fill value

    integer,intent(in) :: arraylen
    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: carraylen
    type(C_PTR) :: cptr
    carraylen = int(arraylen,C_SIZE_T)
    cptr = C_LOC(array)
#ifdef TIMING
    call t_startf("PIO:write_darray_real")
#endif
    if(present(fillval)) then
       iostat = PIOc_write_darray(file%fh, varDesc%varid-1, iodesc%ioid, carraylen,cptr, C_LOC(fillval))
    else
       iostat = PIOc_write_darray(file%fh, varDesc%varid-1, iodesc%ioid, carraylen, cptr, C_NULL_PTR)
    endif
#ifdef TIMING
    call t_stopf("PIO:write_darray_real")
#endif
# 151 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_1d_cinterface_real
! TYPE real,int,double
# 110 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_1d_cinterface_int (File,varDesc,ioDesc, arraylen, array, iostat, fillval)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Writes a 2-d slab of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), dimension(*), target, intent(in) ::  &
         array                 ! array to be written

    integer(i4), optional, target, intent(in) :: fillval    ! rearrange receiver fill value

    integer,intent(in) :: arraylen
    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: carraylen
    type(C_PTR) :: cptr
    carraylen = int(arraylen,C_SIZE_T)
    cptr = C_LOC(array)
#ifdef TIMING
    call t_startf("PIO:write_darray_int")
#endif
    if(present(fillval)) then
       iostat = PIOc_write_darray(file%fh, varDesc%varid-1, iodesc%ioid, carraylen,cptr, C_LOC(fillval))
    else
       iostat = PIOc_write_darray(file%fh, varDesc%varid-1, iodesc%ioid, carraylen, cptr, C_NULL_PTR)
    endif
#ifdef TIMING
    call t_stopf("PIO:write_darray_int")
#endif
# 151 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_1d_cinterface_int
! TYPE real,int,double
# 110 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_1d_cinterface_double (File,varDesc,ioDesc, arraylen, array, iostat, fillval)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Writes a 2-d slab of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), dimension(*), target, intent(in) ::  &
         array                 ! array to be written

    real(r8), optional, target, intent(in) :: fillval    ! rearrange receiver fill value

    integer,intent(in) :: arraylen
    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: carraylen
    type(C_PTR) :: cptr
    carraylen = int(arraylen,C_SIZE_T)
    cptr = C_LOC(array)
#ifdef TIMING
    call t_startf("PIO:write_darray_double")
#endif
    if(present(fillval)) then
       iostat = PIOc_write_darray(file%fh, varDesc%varid-1, iodesc%ioid, carraylen,cptr, C_LOC(fillval))
    else
       iostat = PIOc_write_darray(file%fh, varDesc%varid-1, iodesc%ioid, carraylen, cptr, C_NULL_PTR)
    endif
#ifdef TIMING
    call t_stopf("PIO:write_darray_double")
#endif
# 151 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_1d_cinterface_double

! TYPE real,int,double
# 154 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_multi_1d_cinterface_real (File,varDesc,ioDesc,nvars,arraylen, array, iostat, fillval)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Writes a 2-d slab of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc(:)                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer, intent(in) :: nvars

    real(r4), dimension(*), target, intent(in) ::  array                ! array to be written

    real(r4), optional, target, intent(in) :: fillval    ! rearrange receiver fill value

    integer,intent(in) :: arraylen
    integer(i4), intent(out) :: iostat
    integer(C_INT) :: varid(nvars)
    integer(C_SIZE_T) :: carraylen
    type(C_PTR) :: cptr
    integer :: i
    carraylen = int(arraylen,C_SIZE_T)

    cptr = C_LOC(array)
    do i=1,nvars
       varid(i) = vardesc(i)%varid-1
    end do

    if(present(fillval)) then
       iostat = PIOc_write_darray_multi(file%fh, varid, iodesc%ioid, nvars, carraylen,cptr, C_LOC(fillval))
    else
       iostat = PIOc_write_darray_multi(file%fh, varid, iodesc%ioid, nvars, carraylen, cptr, C_NULL_PTR)
    endif

# 198 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_multi_1d_cinterface_real
! TYPE real,int,double
# 154 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_multi_1d_cinterface_int (File,varDesc,ioDesc,nvars,arraylen, array, iostat, fillval)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Writes a 2-d slab of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc(:)                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer, intent(in) :: nvars

    integer(i4), dimension(*), target, intent(in) ::  array                ! array to be written

    integer(i4), optional, target, intent(in) :: fillval    ! rearrange receiver fill value

    integer,intent(in) :: arraylen
    integer(i4), intent(out) :: iostat
    integer(C_INT) :: varid(nvars)
    integer(C_SIZE_T) :: carraylen
    type(C_PTR) :: cptr
    integer :: i
    carraylen = int(arraylen,C_SIZE_T)

    cptr = C_LOC(array)
    do i=1,nvars
       varid(i) = vardesc(i)%varid-1
    end do

    if(present(fillval)) then
       iostat = PIOc_write_darray_multi(file%fh, varid, iodesc%ioid, nvars, carraylen,cptr, C_LOC(fillval))
    else
       iostat = PIOc_write_darray_multi(file%fh, varid, iodesc%ioid, nvars, carraylen, cptr, C_NULL_PTR)
    endif

# 198 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_multi_1d_cinterface_int
! TYPE real,int,double
# 154 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_multi_1d_cinterface_double (File,varDesc,ioDesc,nvars,arraylen, array, iostat, fillval)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Writes a 2-d slab of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc(:)                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer, intent(in) :: nvars

    real(r8), dimension(*), target, intent(in) ::  array                ! array to be written

    real(r8), optional, target, intent(in) :: fillval    ! rearrange receiver fill value

    integer,intent(in) :: arraylen
    integer(i4), intent(out) :: iostat
    integer(C_INT) :: varid(nvars)
    integer(C_SIZE_T) :: carraylen
    type(C_PTR) :: cptr
    integer :: i
    carraylen = int(arraylen,C_SIZE_T)

    cptr = C_LOC(array)
    do i=1,nvars
       varid(i) = vardesc(i)%varid-1
    end do

    if(present(fillval)) then
       iostat = PIOc_write_darray_multi(file%fh, varid, iodesc%ioid, nvars, carraylen,cptr, C_LOC(fillval))
    else
       iostat = PIOc_write_darray_multi(file%fh, varid, iodesc%ioid, nvars, carraylen, cptr, C_NULL_PTR)
    endif

# 198 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_multi_1d_cinterface_double

! TYPE real,int,double
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 1D array of type real.
!! @details
!! @param File    \ref file_desc_t
!! @param varDesc \ref var_desc_t
!! @param ioDesc  \ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 213 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_multi_1d_real (File,varDesc,ioDesc, array, iostat, fillval)
    ! !DESCRIPTION:
    !  Writes a block of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc(:)                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), dimension(:), target, intent(in) ::  &
         array                 ! array to be written

    real(r4), optional, target, intent(in) :: fillval    ! rearrange receiver fill value
    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::write_darray_real'
    integer :: nvars

    nvars = size(vardesc)

    call write_darray_multi_1d_cinterface_real (file, varDesc, iodesc, nvars, size(array), array, iostat, fillval)

# 244 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_multi_1d_real
! TYPE real,int,double
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 1D array of type int.
!! @details
!! @param File    \ref file_desc_t
!! @param varDesc \ref var_desc_t
!! @param ioDesc  \ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 213 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_multi_1d_int (File,varDesc,ioDesc, array, iostat, fillval)
    ! !DESCRIPTION:
    !  Writes a block of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc(:)                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), dimension(:), target, intent(in) ::  &
         array                 ! array to be written

    integer(i4), optional, target, intent(in) :: fillval    ! rearrange receiver fill value
    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::write_darray_int'
    integer :: nvars

    nvars = size(vardesc)

    call write_darray_multi_1d_cinterface_int (file, varDesc, iodesc, nvars, size(array), array, iostat, fillval)

# 244 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_multi_1d_int
! TYPE real,int,double
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 1D array of type double.
!! @details
!! @param File    \ref file_desc_t
!! @param varDesc \ref var_desc_t
!! @param ioDesc  \ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 213 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_multi_1d_double (File,varDesc,ioDesc, array, iostat, fillval)
    ! !DESCRIPTION:
    !  Writes a block of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc(:)                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), dimension(:), target, intent(in) ::  &
         array                 ! array to be written

    real(r8), optional, target, intent(in) :: fillval    ! rearrange receiver fill value
    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::write_darray_double'
    integer :: nvars

    nvars = size(vardesc)

    call write_darray_multi_1d_cinterface_double (file, varDesc, iodesc, nvars, size(array), array, iostat, fillval)

# 244 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_multi_1d_double

! TYPE real,int,double
# 247 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_1d_real (File,varDesc,ioDesc, array, iostat, fillval)
    ! !DESCRIPTION:
    !  Writes a block of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), dimension(:), target, intent(in) ::  &
         array                 ! array to be written

    real(r4), optional, target, intent(in) :: fillval    ! rearrange receiver fill value
    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::write_darray_real'

    call write_darray_1d_cinterface_real (file, varDesc, iodesc, size(array), array, iostat, fillval)

# 275 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_1d_real
! TYPE real,int,double
# 247 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_1d_int (File,varDesc,ioDesc, array, iostat, fillval)
    ! !DESCRIPTION:
    !  Writes a block of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), dimension(:), target, intent(in) ::  &
         array                 ! array to be written

    integer(i4), optional, target, intent(in) :: fillval    ! rearrange receiver fill value
    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::write_darray_int'

    call write_darray_1d_cinterface_int (file, varDesc, iodesc, size(array), array, iostat, fillval)

# 275 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_1d_int
! TYPE real,int,double
# 247 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_1d_double (File,varDesc,ioDesc, array, iostat, fillval)
    ! !DESCRIPTION:
    !  Writes a block of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), dimension(:), target, intent(in) ::  &
         array                 ! array to be written

    real(r8), optional, target, intent(in) :: fillval    ! rearrange receiver fill value
    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::write_darray_double'

    call write_darray_1d_cinterface_double (file, varDesc, iodesc, size(array), array, iostat, fillval)

# 275 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_1d_double

! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 2D array of type real.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_2d_real (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), intent(in) ::  &
         array(:,:)                 ! array to be written

    real(r4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_real (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_real (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_real (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_2d_real
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 3D array of type real.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_3d_real (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), intent(in) ::  &
         array(:,:,:)                 ! array to be written

    real(r4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_real (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_real (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_real (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_3d_real
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 4D array of type real.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_4d_real (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), intent(in) ::  &
         array(:,:,:,:)                 ! array to be written

    real(r4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_real (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_real (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_real (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_4d_real
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 5D array of type real.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_5d_real (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), intent(in) ::  &
         array(:,:,:,:,:)                 ! array to be written

    real(r4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_real (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_real (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_real (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_5d_real
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 6D array of type real.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_6d_real (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), intent(in) ::  &
         array(:,:,:,:,:,:)                 ! array to be written

    real(r4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_real (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_real (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_real (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_6d_real
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 7D array of type real.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_7d_real (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r4), intent(in) ::  &
         array(:,:,:,:,:,:,:)                 ! array to be written

    real(r4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_real (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_real (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_real (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_7d_real
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 2D array of type int.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_2d_int (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), intent(in) ::  &
         array(:,:)                 ! array to be written

    integer(i4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    integer(i4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    integer(i4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_int (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_int (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_int (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_2d_int
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 3D array of type int.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_3d_int (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), intent(in) ::  &
         array(:,:,:)                 ! array to be written

    integer(i4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    integer(i4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    integer(i4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_int (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_int (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_int (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_3d_int
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 4D array of type int.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_4d_int (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), intent(in) ::  &
         array(:,:,:,:)                 ! array to be written

    integer(i4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    integer(i4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    integer(i4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_int (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_int (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_int (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_4d_int
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 5D array of type int.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_5d_int (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), intent(in) ::  &
         array(:,:,:,:,:)                 ! array to be written

    integer(i4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    integer(i4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    integer(i4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_int (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_int (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_int (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_5d_int
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 6D array of type int.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_6d_int (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), intent(in) ::  &
         array(:,:,:,:,:,:)                 ! array to be written

    integer(i4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    integer(i4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    integer(i4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_int (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_int (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_int (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_6d_int
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 7D array of type int.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_7d_int (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    integer(i4), intent(in) ::  &
         array(:,:,:,:,:,:,:)                 ! array to be written

    integer(i4), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    integer(i4) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    integer(i4), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_int (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_int (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_int (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_7d_int
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 2D array of type double.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_2d_double (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), intent(in) ::  &
         array(:,:)                 ! array to be written

    real(r8), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r8) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r8), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_double (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_double (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_double (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_2d_double
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 3D array of type double.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_3d_double (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), intent(in) ::  &
         array(:,:,:)                 ! array to be written

    real(r8), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r8) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r8), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_double (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_double (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_double (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_3d_double
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 4D array of type double.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_4d_double (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), intent(in) ::  &
         array(:,:,:,:)                 ! array to be written

    real(r8), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r8) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r8), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_double (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_double (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_double (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_4d_double
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 5D array of type double.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_5d_double (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), intent(in) ::  &
         array(:,:,:,:,:)                 ! array to be written

    real(r8), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r8) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r8), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_double (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_double (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_double (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_5d_double
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 6D array of type double.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_6d_double (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), intent(in) ::  &
         array(:,:,:,:,:,:)                 ! array to be written

    real(r8), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r8) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r8), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_double (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_double (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_double (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_6d_double
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 7D array of type double.
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<
# 291 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine write_darray_7d_double (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    real(r8), intent(in) ::  &
         array(:,:,:,:,:,:,:)                 ! array to be written

    real(r8), optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    real(r8) :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    real(r8), allocatable :: acopy(:)
    integer :: isize

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_double (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_double (File, varDesc, iodesc, dumbvar, iostat)
    else
       call write_darray_1d_double (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
# 330 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine write_darray_7d_double

! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type real from a netCDF variable of 1 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_1d_real (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r4), intent(out) ::  array(:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_real (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_1d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type real from a netCDF variable of 2 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_2d_real (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r4), intent(out) ::  array(:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_real (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_2d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type real from a netCDF variable of 3 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_3d_real (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r4), intent(out) ::  array(:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_real (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_3d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type real from a netCDF variable of 4 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_4d_real (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r4), intent(out) ::  array(:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_real (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_4d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type real from a netCDF variable of 5 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_5d_real (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r4), intent(out) ::  array(:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_real (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_5d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type real from a netCDF variable of 6 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_6d_real (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r4), intent(out) ::  array(:,:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_real (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_6d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type real from a netCDF variable of 7 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_7d_real (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r4), intent(out) ::  array(:,:,:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_real (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_7d_real
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type int from a netCDF variable of 1 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_1d_int (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    integer(i4), intent(out) ::  array(:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_int (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_1d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type int from a netCDF variable of 2 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_2d_int (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    integer(i4), intent(out) ::  array(:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_int (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_2d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type int from a netCDF variable of 3 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_3d_int (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    integer(i4), intent(out) ::  array(:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_int (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_3d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type int from a netCDF variable of 4 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_4d_int (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    integer(i4), intent(out) ::  array(:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_int (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_4d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type int from a netCDF variable of 5 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_5d_int (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    integer(i4), intent(out) ::  array(:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_int (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_5d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type int from a netCDF variable of 6 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_6d_int (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    integer(i4), intent(out) ::  array(:,:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_int (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_6d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type int from a netCDF variable of 7 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_7d_int (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    integer(i4), intent(out) ::  array(:,:,:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_int (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_7d_int
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type double from a netCDF variable of 1 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_1d_double (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r8), intent(out) ::  array(:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_double (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_1d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type double from a netCDF variable of 2 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_2d_double (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r8), intent(out) ::  array(:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_double (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_2d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type double from a netCDF variable of 3 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_3d_double (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r8), intent(out) ::  array(:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_double (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_3d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type double from a netCDF variable of 4 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_4d_double (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r8), intent(out) ::  array(:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_double (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_4d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type double from a netCDF variable of 5 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_5d_double (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r8), intent(out) ::  array(:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_double (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_5d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type double from a netCDF variable of 6 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_6d_double (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r8), intent(out) ::  array(:,:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_double (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_6d_double
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
!>
!! @public
!! @ingroup PIO_read_darray
!! @brief Read distributed array of type double from a netCDF variable of 7 dimension(s).
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
# 345 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_7d_double (File,varDesc, ioDesc, array, iostat)
    use iso_c_binding
!    use ifcore, only: tracebackqq
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! iodecomp descriptor

    real(r8), intent(out) ::  array(:,:,:,:,:,:,:)                 ! array to be read

    integer(i4), intent(out) :: iostat
    integer(C_SIZE_T) :: tlen

    tlen = size(array)
    call read_darray_internal_double (File%fh, vardesc%varid, iodesc%ioid, tlen, array, iostat)

# 373 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_7d_double

! TYPE real,int,double

# 377 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_internal_real (ncid, varid, ioid, alen, array, iostat)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:
    integer, intent(in) :: ncid, varid, ioid
    integer(C_SIZE_T), intent(in) :: alen

    real(r4), target ::  array(*)                 ! array to be read

    integer(i4), intent(out) :: iostat
    type(C_PTR) :: cptr
    character(len=*), parameter :: subName=modName//'::read_darray_real'

    cptr = C_LOC(array)
    iostat = PIOc_read_darray(ncid, varid-1, ioid, alen, cptr)

# 398 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_internal_real
! TYPE real,int,double

# 377 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_internal_int (ncid, varid, ioid, alen, array, iostat)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:
    integer, intent(in) :: ncid, varid, ioid
    integer(C_SIZE_T), intent(in) :: alen

    integer(i4), target ::  array(*)                 ! array to be read

    integer(i4), intent(out) :: iostat
    type(C_PTR) :: cptr
    character(len=*), parameter :: subName=modName//'::read_darray_int'

    cptr = C_LOC(array)
    iostat = PIOc_read_darray(ncid, varid-1, ioid, alen, cptr)

# 398 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_internal_int
! TYPE real,int,double

# 377 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  subroutine read_darray_internal_double (ncid, varid, ioid, alen, array, iostat)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:
    integer, intent(in) :: ncid, varid, ioid
    integer(C_SIZE_T), intent(in) :: alen

    real(r8), target ::  array(*)                 ! array to be read

    integer(i4), intent(out) :: iostat
    type(C_PTR) :: cptr
    character(len=*), parameter :: subName=modName//'::read_darray_double'

    cptr = C_LOC(array)
    iostat = PIOc_read_darray(ncid, varid-1, ioid, alen, cptr)

# 398 "/home/ed/tmp/ParallelIO/src/flib/piodarray.F90.in"
  end subroutine read_darray_internal_double

end module piodarray
