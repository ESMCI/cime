

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6. Controlling processors and threads &mdash; CIME master documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=30d551ce"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7. Porting and validating CIME on a new platform" href="porting-cime.html" />
    <link rel="prev" title="5. Defining the machine" href="machine.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            CIME
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../what_cime/index.html">What is CIME?</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Using the Case Control System</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html#configuring-the-case-control-system">Configuring the Case Control System</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="cime-internals.html">1. Main Configuration File</a></li>
<li class="toctree-l2"><a class="reference internal" href="components.html">2. Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="compsets.html">3. Component sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="grids.html">4. Model grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="machine.html">5. Defining the machine</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6. Controlling processors and threads</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pe-settings-for-a-case">6.1. pe-settings for a case</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-the-pe-layout">6.2. Setting the PE layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#case-resource-allocation">6.3. Case Resource Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimizing-processor-layout">6.4. Optimizing processor layout</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="porting-cime.html">7. Porting and validating CIME on a new platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit_testing.html">8. Fortran Unit Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi-instance.html">9. Multi-instance component functionality</a></li>
<li class="toctree-l2"><a class="reference internal" href="workflows.html">10. Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="cime-dir.html">11. Directory content</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../build_cpl/index.html">Building a Coupled Model with CIME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc_tools/index.html">Miscellaneous Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../glossary/index.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tools_user/index.html">User Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xml_files/index.html">XML Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CIME_api/modules.html">CIME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tools_api/modules.html">Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CIME</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Using the Case Control System</a></li>
      <li class="breadcrumb-item active"><span class="section-number">6. </span>Controlling processors and threads</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/users_guide/pes-threads.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="controlling-processors-and-threads">
<span id="pesthreads"></span><h1><span class="section-number">6. </span>Controlling processors and threads<a class="headerlink" href="#controlling-processors-and-threads" title="Link to this heading"></a></h1>
<p>Once a compset and resolution for a case has been defined, CIME
provides ways to define the processor layout the case will use.</p>
<p>CIME cases have significant flexibility with respect to the layout of
components across different hardware processors. There are up to eight
unique models (atm, lnd, rof, ocn, ice, glc, wav, cpl) that are
managed independently by the CIME driver, each with a unique MPI
communicator.  In addition, the driver runs on the union of all
processors and controls the sequencing and hardware partitioning.</p>
<section id="pe-settings-for-a-case">
<span id="defining-pes"></span><h2><span class="section-number">6.1. </span>pe-settings for a case<a class="headerlink" href="#pe-settings-for-a-case" title="Link to this heading"></a></h2>
<p>CIME looks at the xml element <code class="docutils literal notranslate"><span class="pre">PES_SPEC_FILE</span></code> in the <strong>$CIMEROOT/config/$model/config_files.xml</strong> file to determine where
to find the supported out-of-the-box model pe-settings for the primary component (See <a class="reference internal" href="compsets.html#compsets"><span class="std std-ref">Compsets</span></a> for definition of primary component.)</p>
<p>When your run <a class="reference external" href="../Tools_user/create_newcase.html">create_newcase</a>, CIME identifies the primary component and the setting of the <code class="docutils literal notranslate"><span class="pre">PES_SPEC_FILE</span></code> in the standard output.</p>
<p>By default, each primary component has a <strong>config_pes.xml</strong> file in
its <strong>cime_config</strong> directory.  That file specifies out-of-the-box
pe-layout for compsets that the primary component defines.  Currently,
the pe-layout can have dependencies on the compset, the model grid and
the target machine.  Finally, there might be more than one
out-of-the-box pe-layout that could be used for a compset/grid/machine
combination: one for a low processor setting and one for a high
processor setting.</p>
<p>A typical entry in a <strong>config_pes.xml</strong> looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">grid</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;a%T62&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">mach</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cheyenne&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">pes</span> <span class="n">pesize</span><span class="o">=</span><span class="s2">&quot;any&quot;</span> <span class="n">compset</span><span class="o">=</span><span class="s2">&quot;DATM%IAF&quot;</span><span class="o">&gt;</span>
    <span class="o">.......</span>
    <span class="o">&lt;/</span><span class="n">pes</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">mach</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">grid</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Currently, the pesize can have values of <code class="docutils literal notranslate"><span class="pre">[any,S,M,L,X1,X2]</span></code>.</p>
<p>Given the various dependencies, CIME uses an order of precedence to determine the optimal match. This order is as follows:</p>
<ol class="arabic">
<li><p>grid match</p>
<div class="line-block">
<div class="line">CIME first searches the grid nodes for a grid match in <strong>config_grids.xml</strong>.</div>
<div class="line">The search is based on a regular expression match for the grid longname.</div>
<div class="line">All grid matches are then used in the subsequent search.</div>
<div class="line">If there is no grid match, all nodes that have <code class="docutils literal notranslate"><span class="pre">&lt;grid</span> <span class="pre">name=&quot;any&quot;&gt;</span></code> are used in the subsequent search.</div>
</div>
</li>
<li><p>machine match</p>
<div class="line-block">
<div class="line">CIME next uses the list of nodes obtained in the grid match to search for the machine name using the <code class="docutils literal notranslate"><span class="pre">&lt;mach&gt;</span></code> nodes.</div>
<div class="line">If there is no machine match, then all nodes with <code class="docutils literal notranslate"><span class="pre">&lt;machine</span> <span class="pre">name=&quot;any&quot;&gt;</span></code> are used in the subsequent search.</div>
</div>
</li>
<li><p>pesize and compset match</p>
<div class="line-block">
<div class="line">CIME next uses the list of nodes obtained in the machine match to search for pesize and compset using the <code class="docutils literal notranslate"><span class="pre">&lt;pes&gt;</span></code> nodes.</div>
<div class="line">If there is no match, the node with <code class="docutils literal notranslate"><span class="pre">&lt;pes</span> <span class="pre">pesize=&quot;any&quot;</span> <span class="pre">compset=&quot;any&quot;&gt;</span></code> is used.</div>
</div>
</li>
</ol>
<p>When <a class="reference external" href="../Tools_user/create_newcase.html">create_newcase</a>  is called, it outputs the matches that are found in determining the best out-of-the-box pe-layout.</p>
</section>
<section id="setting-the-pe-layout">
<h2><span class="section-number">6.2. </span>Setting the PE layout<a class="headerlink" href="#setting-the-pe-layout" title="Link to this heading"></a></h2>
<p>Optimizing the throughput and efficiency of a CIME experiment often
involves customizing the processor (PE) layout. (See <a class="reference internal" href="#optimizing-processor-layout"><span class="std std-ref">load
balancing</span></a>.)  CIME provides significant
flexibility with respect to the layout of components across different
hardware processors.  In general, the CIME components – atm, lnd,
ocn, and so on – can run on overlapping or mutually unique
processors.  While each component is associated with a unique MPI
communicator, the CIME driver runs on the union of all processors and
controls the sequencing and hardware partitioning.</p>
<p>The pe-layout settings are controlled by the <code class="docutils literal notranslate"><span class="pre">$CASEROOT</span></code> file
<strong>env_mach_pes.xml</strong> file. Variables in this file determine the number
of MPI tasks and OpenMP threads for each component, the number of
instances of each component and the layout of the components across
the hardware processors. The entries in <strong>env_mach_pes.xml</strong> have the
following meanings:</p>
<table class="docutils align-default" id="id3">
<caption><span class="caption-text">Entries in <strong>env_mach_pes.xml</strong></span><a class="headerlink" href="#id3" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>XML variable</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MAX_MPITASKS_PER_NODE</p></td>
<td><p>The maximum number of MPI tasks per node. This is defined in <strong>config_machines.xml</strong> and therefore given a default setting, but can be user modified.</p></td>
</tr>
<tr class="row-odd"><td><p>MAX_TASKS_PER_NODE</p></td>
<td><p>The total number of (MPI tasks) * (OpenMP threads) allowed on a node. This is defined in <strong>config_machines.xml</strong> and therefore given a default setting, but can be user modified. Some computational platforms use a special software customized for the target hardware called symmetric multi-threading (SMT). This allows for over-subscription of the hardware cores. In cases where this is beneficial to model performance, the variable <code class="docutils literal notranslate"><span class="pre">MAX_TASKS_PER_NODE</span></code> will be greater than the hardware cores per node as specified by <code class="docutils literal notranslate"><span class="pre">MAX_MPITASKS_PER_NODE</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>NTASKS</p></td>
<td><p>Total number of MPI tasks. A negative value indicates nodes rather than tasks, where <em>MAX_MPITASKS_PER_NODE * -NTASKS</em> equals the number of MPI tasks.</p></td>
</tr>
<tr class="row-odd"><td><p>NTHRDS</p></td>
<td><p>Number of OpenMP threads per MPI task. <code class="docutils literal notranslate"><span class="pre">NTHRDS</span></code> must be greater than or equal to 1. If <code class="docutils literal notranslate"><span class="pre">NTHRDS</span></code> = 1, this generally means threading parallelization will be off for the given component.</p></td>
</tr>
<tr class="row-even"><td><p>ROOTPE</p></td>
<td><p>The global MPI task of the component root task; if negative, indicates nodes rather than tasks. The root processor for each component is set relative to the MPI global communicator.</p></td>
</tr>
<tr class="row-odd"><td><p>PSTRID</p></td>
<td><p>The stride of MPI tasks across the global set of pes (for now set to 1). This variable is currently not used and is a placeholder for future development.</p></td>
</tr>
<tr class="row-even"><td><p>NINST</p></td>
<td><p>The number of component instances, which are spread evenly across NTASKS.</p></td>
</tr>
<tr class="row-odd"><td><p>COST_PER_NODE</p></td>
<td><p>The numbers of cores/node used for accounting purposes. The user should not normally need to set this - but it is useful for understanding how you will be charged.</p></td>
</tr>
</tbody>
</table>
<p>Each CIME component has corresponding entries for <code class="docutils literal notranslate"><span class="pre">NTASKS</span></code>, <code class="docutils literal notranslate"><span class="pre">NTHRDS</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOTPE</span></code> and <code class="docutils literal notranslate"><span class="pre">NINST</span></code> in the <strong>env_mach_pes.xml</strong> file. The layout of components on processors has no impact on the science.
If all components have identical <code class="docutils literal notranslate"><span class="pre">NTASKS</span></code>, <code class="docutils literal notranslate"><span class="pre">NTHRDS</span></code>, and <code class="docutils literal notranslate"><span class="pre">ROOTPE</span></code> settings, all components will exectute sequentially on the same hardware processors.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>To view the current settings, use the <a class="reference external" href="../Tools_user/pelayout.html">pelayout</a> tool</p>
</div>
<p>The time sequencing is hardwired into the driver. Changing
processor layouts does not change intrinsic coupling lags or coupling
sequencing.</p>
<p>The coupler component has its own processor set for doing
computations such as mapping, merging, diagnostics, and flux
calculation.  This is distinct from the driver, which always
runs on the union of all processors to manage model concurrency and
sequencing.</p>
<p>For a <strong>fully active configuration</strong>, the atmosphere component is
hardwired in the driver to never run concurrently with the land or ice
component.  Performance improvements associated with processor layout
concurrency therefore are constrained in this case such that there is
never a performance reason not to overlap the atmosphere component
with the land and ice components.  Beyond that constraint, the land,
ice, coupler and ocean models can run concurrently, and the ocean
model can also run concurrently with the atmosphere model.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if <strong>env_mach_pes.xml</strong> is modified after <a class="reference external" href="../Tools_user/case.setup.html">case.setup</a>  has been called, then you must run <a class="reference external" href="../Tools_user/case.setup.html">case.setup –reset</a> and the call <a class="reference external" href="../Tools_user/case.build.html">case.build</a>.  <strong>case.build</strong> will only recompile any source code that depends on values in <strong>env_mach_pes.xml</strong></p>
</div>
</section>
<section id="case-resource-allocation">
<h2><span class="section-number">6.3. </span>Case Resource Allocation<a class="headerlink" href="#case-resource-allocation" title="Link to this heading"></a></h2>
<p>Resources for your case will be allocated according to the following logic.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NTASKS</span></code> * <code class="docutils literal notranslate"><span class="pre">NTHRDS</span></code> is the total number of hardware processors allocated to a component.</p></li>
<li><p>The total number of cores that are allocated will be based on the product of (1) and (2) below where</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MAX(ROOTPE(comp)</span> <span class="pre">+</span> <span class="pre">NTASKS(comp))</span></code> across all components</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MAX(NTHRDS)</span></code> across all components</p></li>
</ol>
</li>
</ul>
<p>In the following example, the atmosphere and ocean will run concurrently. The atmosphere will use 16 MPI tasks each with 4 threads per task for a total of 64 cores. The ocean will use 16 MPI tasks with 1 thread per task. BUT since the atmosphere has 4 threads, the ocean will use 64 total cores. The total number of cores will be 128. The atmosphere will run on MPI tasks 0-15 and the ocean will run on MPI tasks 16-31 in the global MPI communicators.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NTASKS_ATM</span><span class="o">=</span><span class="mi">16</span> <span class="n">NTHRDS_ATM</span><span class="o">=</span><span class="mi">4</span>  <span class="n">ROOTPE_ATM</span><span class="o">=</span><span class="mi">0</span>
<span class="n">NTASKS_OCN</span><span class="o">=</span><span class="mi">16</span> <span class="n">NTHRDS_OCN</span><span class="o">=</span><span class="mi">1</span>  <span class="n">ROOTPE_OCN</span><span class="o">=</span><span class="mi">16</span>
</pre></div>
</div>
</div></blockquote>
<p>CIME ensures that the batch submission script (<a class="reference external" href="../Tools_user/case.submit.html">case.submit</a> ) will automatically requests 128
hardware processors, and the first 16 MPI tasks will be laid out on
the first 64 hardware processors with a stride of 4. The next 16 MPI
tasks are laid out on the second set of 64 hardware processors in the
same manner, even though the ocean is not threaded.  If you had set
<code class="docutils literal notranslate"><span class="pre">ROOTPE_OCN</span></code> to 64 in this example, a total of 312 processors would
be requested, the atmosphere would be laid out on the first 64
hardware processors in 16x4 fashion, and the ocean model would be laid
out on hardware processors 255-311. Hardware processors 64-254 would
be allocated but completely idle.</p>
<p>We strongly encourage you to use the <a class="reference external" href="../Tools_user/preview_run.html">preview_run</a> script to review the environment
and job submit commands for your case.</p>
</section>
<section id="optimizing-processor-layout">
<span id="id2"></span><h2><span class="section-number">6.4. </span>Optimizing processor layout<a class="headerlink" href="#optimizing-processor-layout" title="Link to this heading"></a></h2>
<p>Load balancing is the practice of specifying a processor layout for a given model configuration
(compset, grid, and so on) to maximize simulation speed while minimizing processor idle time.
For a fixed total number of processors, the goal of this optimization is to achieve maximum throughput.
For a set of processor counts, the purpose is to find several “sweet spots” where
the model is minimally idle, cost is relatively low, and the throughput is relatively high.</p>
<p>As with most models, increasing total processors normally results in both increased throughput
and increased cost.
If models scaled linearly, the cost would remain constant across different processor counts,
but models generally don’t scale linearly and the cost increases as processor count increases.</p>
<p>Performing a load-balancing exercise on a proposed case before
undertaking a long production run is recommended practice.  Load
balancing requires you to consider a number of factors, such as which
components are run; their absolute and relative resolution; cost,
scaling and processor count sweet spots for each component; and
internal load imbalance within a component.</p>
<p>It is often best to load balance a system with all significant
run-time I/O turned off because it occurs infrequently, typically just
one timestep per simulated  month. It is best treated as a separate cost as it
can otherwise bias interpretation of the overall balance.  Also, the
use of OpenMP threading in some or all of the components is dependent
on the hardware/OS support as well as whether the system supports
running all MPI and mixed MPI/OpenMP on overlapping processors for
different components.</p>
<p>Finally, decide whether components should run sequentially, concurrently, or in some combination.</p>
<p>Typically, a series of short test runs with the desired production
configuration can establish a reasonable load balance setup for the
production job. The timing output can be used to compare test runs to
help determine the optimal load balance.</p>
<p>Changing the pe layout of the model has NO IMPACT on the scientific
results. The basic order of operations and calling sequence are
hardwired into the driver and do not change with the pe
layout. However, both CESM and E3SM do impose some contraints in the
tempororal evolution of the components.  For example, the prognostic
atmosphere model always run sequentially with the ice and land models
for scientific reasons. As a result, running the atmosphere
concurrently with the ice and land will result in idle processors at
some point in the timestepping sequence.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If you need to load balance a fully coupled case, use the <a class="reference internal" href="../misc_tools/load-balancing-tool.html#load-balancing-tool"><span class="std std-ref">Load Balancing Tool</span></a></p>
</div>
<p><strong>One approach to load balancing</strong></p>
<p>Carry out a <a class="reference internal" href="testing.html#testing"><span class="std std-ref">PFS test</span></a>. This test is by default a
20-day model run with restarts and history output turned off. This
should help you find the layout that has the best load balance for the
targeted number of processors. This provides a reasonable performance
estimate for the production run for most of the runtime.</p>
<p>Seasonal variation and spin-up costs can change performance over time,
so even after a production run has started, review the timing output
occasionally to see if any layout changes might improve throughput or
decrease cost.</p>
<p>In determining an optimal load balance for a specific configuration,
two pieces of information are useful.</p>
<ul class="simple">
<li><p>Which components are most expensive.</p></li>
<li><p>How individual components scale. Do they run faster with all MPI or
mixed MPI/OpenMP decomposition strategies? What are their optimal
decompositions at each processor count? If the cost and scaling of
the components are unknown, several short tests with arbitrary
component pe counts can help establish component scaling and sweet
spots.</p></li>
</ul>
<p><strong>Determining an optimal load balance</strong></p>
<ul class="simple">
<li><p>Start with the most expensive component and a fixed optimal processor count and decomposition for that component.</p></li>
<li><p>Vary the concurrency and pe counts of the other components.</p></li>
<li><p>Identify a few potential load balance configurations, then run each a few times to establish run-to-run variability and determine the best layout.</p></li>
</ul>
<p>In all cases, review the component run times in the timing output file for both overall throughput and independent component timings. Identify idle processors by considering the component concurrency in conjunction with the component timing.</p>
<p>In general, a few component layout options are most reasonable:</p>
<ul class="simple">
<li><p>fully sequential,</p></li>
<li><p>fully sequential except the ocean running concurrently,</p></li>
<li><p>fully concurrent except the atmosphere running sequentially with the ice, rof, and land components.</p></li>
</ul>
<p>The concurrency is limited in part by hardwired sequencing in the
driver. The sequencing is set by scientific constraints, although
there may be some addition flexibility with respect to concurrency
when running with mixed active and data models.</p>
<p><strong>Some general rules for finding optimal configurations</strong></p>
<ul class="simple">
<li><p>Make sure you have set a processor layout where each hardware processor is assigned to at least one component. There is rarely a reason to have completely idle processors.</p></li>
<li><p>Make sure your cheapest components keep up with your most expensive components. In other words, a component that runs on 1024 processors should not be waiting on a component running on 16 processors.</p></li>
<li><p>Before running the job, make sure the batch queue settings are set correctly for your run. Review the account numbers, queue names and time limits. The ideal time limit, queue and run length are dependent on each other and on the current model throughput.</p></li>
<li><p>Take full advantage of the hardware resources. If you are charged by the 32-way node, you might as well target a total processor count that is a multiple of 32.</p></li>
<li><p>Keep a single component on a single node, if possible, to minimize internal component communication cost.</p></li>
<li><p>Assume that hardware performance can vary due to contention on the interconnect, file systems, or other areas. If you are unsure of a timing result, run cases multiple times.</p></li>
</ul>
<p>The pe-layout and the associated timings are found in the  <a class="reference internal" href="timers.html#model-timing-data"><span class="std std-ref">timing files</span></a> generated for your run.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="machine.html" class="btn btn-neutral float-left" title="5. Defining the machine" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="porting-cime.html" class="btn btn-neutral float-right" title="7. Porting and validating CIME on a new platform" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017, U.S. National Science Foundation and U.S. Department of Energy.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
     
<script>var version_json_loc = "../../../versions.json";</script>


</footer>
        </div>
      </div>
    </section>
  </div>
  

  <script type="text/javascript">
    let baseUriRegex = /(.*\/cime)\/.*/g;
    let parsedUri = baseUriRegex.exec(document.baseURI);

    if (parsedUri != null && parsedUri.length == 2) {
      let baseUri = parsedUri[1];

      $.get(`${baseUri}/versions/versions.json`, function(data) {
        let versionElement = $("#versions");

        Object.keys(data).forEach(function(key) {
          let value = data[key];

          let item = `<dd><a href="${baseUri}/versions/${key}/html/">${value}</a></dd>`

          versionElement.append(item);
        });
      });
    }
  </script>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: master
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      
      <dl id="versions">
        <dt>Versions</dt>
      </dl>
      
      
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>