

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>8. Fortran Unit Testing &mdash; CIME master documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=30d551ce"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. Multi-instance component functionality" href="multi-instance.html" />
    <link rel="prev" title="7. Porting and validating CIME on a new platform" href="porting-cime.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            CIME
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../what_cime/index.html">What is CIME?</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Using the Case Control System</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html#configuring-the-case-control-system">Configuring the Case Control System</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="cime-internals.html">1. Main Configuration File</a></li>
<li class="toctree-l2"><a class="reference internal" href="components.html">2. Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="compsets.html">3. Component sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="grids.html">4. Model grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="machine.html">5. Defining the machine</a></li>
<li class="toctree-l2"><a class="reference internal" href="pes-threads.html">6. Controlling processors and threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="porting-cime.html">7. Porting and validating CIME on a new platform</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">8. Fortran Unit Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">8.1. Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-a-unit-test">8.1.1. What is a unit test?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overview-of-unit-test-support-in-cime">8.1.2. Overview of unit test support in CIME</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#running-cime-s-fortran-unit-tests">8.2. Running CIME’s Fortran unit tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-add-unit-testing-support-on-your-machine">8.3. How to add unit testing support on your machine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#building-pfunit">8.3.1. Building pFUnit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adding-to-the-appropriate-cmake-file">8.3.2. Adding to the appropriate cmake file</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-write-a-new-unit-test">8.4. How to write a new unit test</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-guidelines-for-writing-unit-tests">8.5. General guidelines for writing unit tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#more-details-on-writing-pfunit-based-unit-tests">8.6. More details on writing pFUnit-based unit tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#assertion-methods">8.6.1. Assertion methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-a-test-class-in-order-to-define-setup-and-teardown-methods">8.6.2. Defining a test class in order to define setUp and tearDown methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#more-on-test-teardown">8.6.3. More on test teardown</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#finding-more-documentation-and-examples">8.7. Finding more documentation and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#more-detailed-examples-in-cime">8.7.1. More detailed examples in CIME</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-pfunit-documentation-sources">8.7.2. Other pFUnit documentation sources</a></li>
<li class="toctree-l4"><a class="reference internal" href="#documentation-of-the-unit-test-build-system">8.7.3. Documentation of the unit test build system</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="multi-instance.html">9. Multi-instance component functionality</a></li>
<li class="toctree-l2"><a class="reference internal" href="workflows.html">10. Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="cime-dir.html">11. Directory content</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../build_cpl/index.html">Building a Coupled Model with CIME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc_tools/index.html">Miscellaneous Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../glossary/index.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tools_user/index.html">User Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xml_files/index.html">XML Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CIME_api/modules.html">CIME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tools_api/modules.html">Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CIME</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Using the Case Control System</a></li>
      <li class="breadcrumb-item active"><span class="section-number">8. </span>Fortran Unit Testing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/users_guide/unit_testing.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="fortran-unit-testing">
<span id="unit-testing"></span><h1><span class="section-number">8. </span>Fortran Unit Testing<a class="headerlink" href="#fortran-unit-testing" title="Link to this heading"></a></h1>
<section id="introduction">
<h2><span class="section-number">8.1. </span>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<section id="what-is-a-unit-test">
<h3><span class="section-number">8.1.1. </span>What is a unit test?<a class="headerlink" href="#what-is-a-unit-test" title="Link to this heading"></a></h3>
<p>A unit test is a fast, self-verifying test of a small piece of code.
A single unit test typically covers 10s to 100s of lines of code; a single function or small module, for example.
It typically runs in milliseconds and produces a simple pass/fail result.</p>
<p>Unit tests:</p>
<ul class="simple">
<li><p>Ensure that code remains correct as it is modified. In this respect, unit tests complement the CIME system tests.</p></li>
<li><p>Ensure that new code is correct.</p></li>
<li><p>Can help guide development, via test-driven development (TDD).</p></li>
<li><p>Provide executable documentation of the intended behavior of a piece of code.</p></li>
<li><p>Support development on your desktop machine.</p></li>
</ul>
</section>
<section id="overview-of-unit-test-support-in-cime">
<h3><span class="section-number">8.1.2. </span>Overview of unit test support in CIME<a class="headerlink" href="#overview-of-unit-test-support-in-cime" title="Link to this heading"></a></h3>
<p>CIME comes with a set of tools to support building and running unit tests.
These consist of:</p>
<ol class="arabic simple">
<li><p>CMake tools to support building and running tests via CMake and CTest.</p></li>
<li><p>A Python script that provides a simple front end for the CMake-based tests.</p></li>
</ol>
<p>The Fortran unit tests use <a class="reference external" href="https://github.com/Goddard-Fortran-Ecosystem/pFUnit">pFUnit</a>, which is a Fortran testing framework that follows conventions of other xUnit frameworks. CIME’s support for pFUnit requires pFUnit version 4 or greater.</p>
</section>
</section>
<section id="running-cime-s-fortran-unit-tests">
<span id="running-unit-tests"></span><h2><span class="section-number">8.2. </span>Running CIME’s Fortran unit tests<a class="headerlink" href="#running-cime-s-fortran-unit-tests" title="Link to this heading"></a></h2>
<p>These instructions assume that you are using a machine that already has pFUnit installed, along with the necessary support in CIME.
If that is not the case, see <a class="reference internal" href="#adding-machine-support"><span class="std std-ref">How to add unit testing support on your machine</span></a>.</p>
<p>From the top-level CIME directory, you can run all of CIME’s Fortran unit tests by running:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>scripts/fortran_unit_testing/run_tests.py<span class="w"> </span>--build-dir<span class="w"> </span>MY_BUILD_DIR
</pre></div>
</div>
<p>You can replace <code class="docutils literal notranslate"><span class="pre">MY_BUILD_DIR</span></code> with a path to the directory where you would like the unit test build files to be placed.
To ensure a completely clean build, use:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>scripts/fortran_unit_testing/run_tests.py<span class="w"> </span>--build-dir<span class="w"> </span><span class="sb">`</span>mktemp<span class="w"> </span>-d<span class="w"> </span>./unit_tests.XXXXXXXX<span class="sb">`</span>
</pre></div>
</div>
<p>Once you have built the unit tests (whether the build was successful or not), you can reuse the same build directory later to speed up the rebuild.
There are a number of useful arguments to <strong>run_tests.py</strong>. For full usage information, run:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>scripts/fortran_unit_testing/run_tests.py<span class="w"> </span>--help
</pre></div>
</div>
<p>If your build is successful, you will get a message like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================
Running CTest tests for __command_line_test__/__command_line_test__.
==================================================
</pre></div>
</div>
<p>This will be followed by a list of tests, with a Pass/Fail message for each, like these examples:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Test project /Users/sacks/cime/unit_tests.0XHUkfqL/__command_line_test__/__command_line_test__
      Start  1: avect_wrapper
 1/17 Test  #1: avect_wrapper ....................   Passed    0.02 sec
      Start  2: seq_map
 2/17 Test  #2: seq_map ..........................   Passed    0.01 sec
      Start  3: glc_elevclass
 3/17 Test  #3: glc_elevclass ....................   Passed    0.01 sec
</pre></div>
</div>
<p>You will also see a final message like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>100% tests passed, 0 tests failed out of 17
</pre></div>
</div>
<p>These unit tests are run automatically as part of <strong>scripts_regression_tests</strong> on machines that have a serial build of pFUnit available for the default compiler.</p>
</section>
<section id="how-to-add-unit-testing-support-on-your-machine">
<span id="adding-machine-support"></span><h2><span class="section-number">8.3. </span>How to add unit testing support on your machine<a class="headerlink" href="#how-to-add-unit-testing-support-on-your-machine" title="Link to this heading"></a></h2>
<p>The following instructions assume that you have ported CIME to your
machine by following the instructions in
<a class="reference internal" href="porting-cime.html"><span class="doc">Porting and validating CIME on a new platform</span></a>.  If you have done that, you can add
unit testing support by building pFUnit on your machine and then
pointing to the build in your ** <em>MACH*_*COMPILER</em>.cmake** file. Those
processes are described in the following sections.</p>
<section id="building-pfunit">
<h3><span class="section-number">8.3.1. </span>Building pFUnit<a class="headerlink" href="#building-pfunit" title="Link to this heading"></a></h3>
<p>Follow the instructions below to build pFUnit using the default compiler on your machine.
That is the default for <strong>run_tests.py</strong> and that is required for <strong>scripts_regression_tests.py</strong> to run the unit tests on your machine.
For the CMake step, we typically build with <code class="docutils literal notranslate"><span class="pre">-DSKIP_MPI=YES</span></code>, <code class="docutils literal notranslate"><span class="pre">-DSKIP_OPENMP=YES</span></code> and <code class="docutils literal notranslate"><span class="pre">-DCMAKE_INSTALL_PREFIX</span></code> set to the directory where you want pFUnit to be installed.
(At this time, no unit tests require parallel support, so we build without MPI support to keep things simple.)
Optionally, you can also provide pFUnit builds with other supported compilers on your machine.</p>
<ol class="arabic">
<li><p>Obtain pFUnit from <a class="reference external" href="https://github.com/Goddard-Fortran-Ecosystem/pFUnit">https://github.com/Goddard-Fortran-Ecosystem/pFUnit</a> (see
<a class="reference external" href="https://github.com/Goddard-Fortran-Ecosystem/pFUnit#obtaining-pfunit">https://github.com/Goddard-Fortran-Ecosystem/pFUnit#obtaining-pfunit</a> for details)</p></li>
<li><p>Create a directory for the build and cd to that directory:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>mkdir<span class="w"> </span>build-dir
&gt;<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build-dir
</pre></div>
</div>
</li>
<li><p>Set up your environment to be similar to the environment used in CIME system builds.
For example, load the appropriate compilers into your path.
An easy way to achieve this is to run the following with an optional compiler argument:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span><span class="nv">$CIMEROOT</span>/CIME/scripts/configure<span class="w"> </span>--mpilib<span class="w"> </span>mpi-serial
</pre></div>
</div>
<p>Then source either <strong>./.env_mach_specific.sh</strong> or <strong>./.env_mach_specific.csh</strong>, depending on your shell.</p>
<p>On some systems, you may need to explicitly set the <code class="docutils literal notranslate"><span class="pre">FC</span></code> and <code class="docutils literal notranslate"><span class="pre">CC</span></code> environment
variables so that pFUnit’s CMake build picks up the correct compilers, e.g., with:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">FC</span><span class="o">=</span>ifort
&gt;<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">CC</span><span class="o">=</span>icc
</pre></div>
</div>
</li>
<li><p>For convenience, set the <code class="docutils literal notranslate"><span class="pre">PFUNIT</span></code> environment variable to point to the location where you want to install pFUnit. For example (in bash):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">PFUNIT</span><span class="o">=</span><span class="nv">$CESMDATAROOT</span>/tools/pFUnit/pFUnit4.7.0_cheyenne_Intel19.1.1_noMPI_noOpenMP
</pre></div>
</div>
</li>
<li><p>Configure and build pFUnit:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>cmake<span class="w"> </span>-DSKIP_MPI<span class="o">=</span>YES<span class="w"> </span>-DSKIP_OPENMP<span class="o">=</span>YES<span class="w"> </span>-DCMAKE_INSTALL_PREFIX<span class="o">=</span><span class="nv">$PFUNIT</span><span class="w"> </span>..
&gt;<span class="w"> </span>make<span class="w"> </span>-j<span class="w"> </span><span class="m">8</span>
</pre></div>
</div>
</li>
<li><p>Run pFUnit’s self-tests:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>make<span class="w"> </span>tests
</pre></div>
</div>
</li>
<li><p>Install pFUnit in the directory you specified earlier:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>make<span class="w"> </span>install
</pre></div>
</div>
</li>
</ol>
<p>You can repeat this process with different compiler environments.
Make sure to choose a different installation directory for each build by setting the <code class="docutils literal notranslate"><span class="pre">PFUNIT</span></code> variable differently.</p>
</section>
<section id="adding-to-the-appropriate-cmake-file">
<h3><span class="section-number">8.3.2. </span>Adding to the appropriate cmake file<a class="headerlink" href="#adding-to-the-appropriate-cmake-file" title="Link to this heading"></a></h3>
<p>After you build pFUnit, tell CIME about your build or builds.
To do this, specify the appropriate path using the <code class="docutils literal notranslate"><span class="pre">PFUNIT_PATH</span></code> CMake variable in the ** <em>MACH*_*COMPILER</em>.cmake** file.
For a build with no MPI or openMP support (as recommended above), the block should look like this (with the actual path replaced with the PFUNIT path you specified when doing the build):</p>
<blockquote>
<div><div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">if</span><span class="w"> </span><span class="p">(</span><span class="s">MPILIB</span><span class="w"> </span><span class="s">STREQUAL</span><span class="w"> </span><span class="s">mpi-serial</span><span class="w"> </span><span class="s">AND</span><span class="w"> </span><span class="s">NOT</span><span class="w"> </span><span class="s">compile_threaded</span><span class="p">)</span>
<span class="w">  </span><span class="nb">set</span><span class="p">(</span><span class="s">PFUNIT_PATH</span><span class="w"> </span><span class="s2">&quot;$ENV{CESMDATAROOT}/tools/pFUnit/pFUnit4.7.0_cheyenne_Intel19.1.1_noMPI_noOpenMP&quot;</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>Once you have specified the path for your build(s), you should be able to run the unit tests by following the instructions in <a class="reference internal" href="#running-unit-tests"><span class="std std-ref">Running CIME’s Fortran unit tests</span></a>.</p>
</section>
</section>
<section id="how-to-write-a-new-unit-test">
<h2><span class="section-number">8.4. </span>How to write a new unit test<a class="headerlink" href="#how-to-write-a-new-unit-test" title="Link to this heading"></a></h2>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Need to write this section. This will draw on some of the information in sections 3 and 4 of <a class="reference external" href="https://github.com/NCAR/cesm_unit_test_tutorial">https://github.com/NCAR/cesm_unit_test_tutorial</a> (though without the clm and cam stuff).</p>
</div>
<p>It should also introduce the role of .pf files, which are referenced several paragraphs later as if already explained.</p>
</section>
<section id="general-guidelines-for-writing-unit-tests">
<h2><span class="section-number">8.5. </span>General guidelines for writing unit tests<a class="headerlink" href="#general-guidelines-for-writing-unit-tests" title="Link to this heading"></a></h2>
<p>Unit tests typically test a small piece of code, on the order of 10-100 lines, as in a single function or small class.</p>
<p>Good unit tests are <strong>“FIRST”</strong>:
(<a class="reference external" href="https://pragprog.com/magazines/2012-01/unit-tests-are-first">https://pragprog.com/magazines/2012-01/unit-tests-are-first</a>):</p>
<ul class="simple">
<li><p><strong>Fast</strong> (milliseconds or less). This means that, generally, they should not do any file i/o. Also, if you are testing a complex function, test it with a simple set of inputs rather than a 10,000-element array that will require a few seconds of runtime to process.</p></li>
<li><p><strong>Independent</strong>. This means that test Y shouldn’t depend on some global variable that text X created. Such dependencies cause problems if the tests run in a different order, if one test is dropped, and so on.</p></li>
<li><p><strong>Repeatable</strong>. This means, for example, that you shouldn’t generate random numbers in your tests.</p></li>
<li><p><strong>Self-verifying</strong>. Don’t write a test that writes out its answers for manual comparison. Tests should generate an automatic pass/fail result.</p></li>
<li><p><strong>Timely</strong>. Write the tests <em>before</em> the production code (TDD) or immediately afterwards - not six months later when it’s time to finally merge your changes onto the trunk and you have forgotten the details. Much of the benefit of unit tests comes from developing them concurrently with the production code.</p></li>
</ul>
<p>Good unit tests test a single, well-defined condition. This generally means that
you make a single call to the function or subroutine that you’re testing, with a
single set of inputs. Usually you need to run multiple tests in order to test
all of the unit’s possible behaviors.</p>
<p>Testing a single condition in each test makes pinpointing problems easier when a test fails.
This also makes it easier to read and understand the tests, allowing them to serve as useful
documentation of how the code should operate.</p>
<p>A good unit test has four distinct pieces:</p>
<ol class="arabic simple">
<li><p><strong>Setup</strong>: For example, creating variables that will be needed for the routine you’re testing. For simple tests, this piece may be empty.</p></li>
<li><p><strong>Exercise</strong>: Calling the routine you’re testing.</p></li>
<li><p><strong>Verify</strong>: Calling assertion methods (next section) to ensure that the results match what you expected.</p></li>
<li><p><strong>Teardown</strong>: For example, deallocating variables. For simple tests, this piece may be empty. If it is needed, however, it is best done in the special tearDown routine discussed in <a class="reference internal" href="#defining-a-test-class-in-order-to-define-setup-and-teardown-methods">Defining a test class in order to define setUp and tearDown methods</a> and <a class="reference internal" href="#more-on-test-teardown">More on test teardown</a>.**</p></li>
</ol>
<p>If you have many tests of the same subroutine, you may find quite a
lot of duplication. It’s good practice to extract major areas of duplication to their own
subroutines in the <strong>.pf</strong> file, which your tests can call. This aids the understandability
and maintainability of your tests. pFUnit knows which subroutines are tests and which are
“helper” routines because of the <code class="docutils literal notranslate"><span class="pre">&#64;Test</span></code> directives: You only add a <code class="docutils literal notranslate"><span class="pre">&#64;Test</span></code> directive
for your tests, not for your helper routines.</p>
</section>
<section id="more-details-on-writing-pfunit-based-unit-tests">
<h2><span class="section-number">8.6. </span>More details on writing pFUnit-based unit tests<a class="headerlink" href="#more-details-on-writing-pfunit-based-unit-tests" title="Link to this heading"></a></h2>
<section id="assertion-methods">
<h3><span class="section-number">8.6.1. </span>Assertion methods<a class="headerlink" href="#assertion-methods" title="Link to this heading"></a></h3>
<p>pFUnit provides many assertion methods that you can use in the Verify step.
Here are some of the most useful:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertEqual(expected,</span> <span class="pre">actual)</span></code></p></td>
<td><p>Ensures that expected == actual.
Accepts an optional <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> argument giving the tolerance for
real-valued comparisons.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertLessThan(expected,</span> <span class="pre">actual)</span></code></p></td>
<td><p>Ensures that expected &lt; actual.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertGreaterThan(expected,</span> <span class="pre">actual)</span></code></p></td>
<td><p>Ensures that expected &gt; actual.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertLessThanOrEqual(expected,</span> <span class="pre">actual)</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertGreaterThanOrEqual(expected,</span> <span class="pre">actual)</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertTrue(condition)</span></code></p></td>
<td><p>It is better to use the two-valued assertions above, if possible.
They provide more information if a test fails.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertFalse(condition)</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertIsFinite(value)</span></code></p></td>
<td><p>Ensures that the result is not NaN or infinity.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;assertIsNan(value)</span></code></p></td>
<td><p>This can be useful for failure checking - for example, when your
function returns NaN to signal an error.</p></td>
</tr>
</tbody>
</table>
<p>Comparison assertions accept an optional <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> argument, which gives the
tolerance for real-valued comparisons.</p>
<p>All of the assertion methods also accept an optional <code class="docutils literal notranslate"><span class="pre">message</span></code> argument, which prints
a string if the assertion fails. If no message is provided, you will be pointed to the
file and line number of the failed assertion.</p>
</section>
<section id="defining-a-test-class-in-order-to-define-setup-and-teardown-methods">
<h3><span class="section-number">8.6.2. </span>Defining a test class in order to define setUp and tearDown methods<a class="headerlink" href="#defining-a-test-class-in-order-to-define-setup-and-teardown-methods" title="Link to this heading"></a></h3>
<p>As noted in the comments in <strong>test_circle.pf</strong>, defining a test class is optional.
However, defining a minimal test class as shown here with <code class="docutils literal notranslate"><span class="pre">TestCircle</span></code> allows you
use some pFUnit features such as the setUp and tearDown methods.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@TestCase
type, extends(TestCase) :: TestCircle
 contains
   procedure :: setUp
   procedure :: tearDown
end type TestCircle
</pre></div>
</div>
<p>If you define this test class, you also need to:</p>
<ul>
<li><p>Define <em>setUp</em> and <em>tearDown</em> subroutines. These can start out empty:</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">setUp</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
<span class="w">  </span><span class="k">class</span><span class="p">(</span><span class="n">TestCircle</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">this</span>
<span class="k">end subroutine </span><span class="n">setUp</span>

<span class="k">subroutine </span><span class="n">tearDown</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
<span class="w">  </span><span class="k">class</span><span class="p">(</span><span class="n">TestCircle</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">this</span>
<span class="k">end subroutine </span><span class="n">tearDown</span>
</pre></div>
</div>
</li>
<li><p>Add an argument to each subroutine of the class. By convention, this argument is named <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p></li>
</ul>
<p>Code in the setUp method is executed before each test. This is convenient
if you need to do some setup that is the same for every test.</p>
<p>Code in the tearDown method is executed after each test. This is often used
to deallocate memory. See <a class="reference internal" href="#more-on-test-teardown">More on test teardown</a> for details.</p>
<p>You can add any data or procedures to the test class. Adding data is
particularly useful, as this can be a way for the setUp and tearDown methods to
interact with your tests: The setUp method can fill a class variable with data,
which your tests can then use (accessed via <code class="docutils literal notranslate"><span class="pre">this%somedata</span></code>). Conversely, if
you want the tearDown method to deallocate a variable, the variable cannot be local
to your test subroutine. Instead, you make the variable a member of the class, so
that the tearDown method can access it.</p>
<p>Here is an example. Say you have this variable in your test class:</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">real</span><span class="p">(</span><span class="n">r8</span><span class="p">),</span><span class="w"> </span><span class="k">pointer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">somedata</span><span class="p">(:)</span>
</pre></div>
</div>
<p>The setUp method can create <code class="docutils literal notranslate"><span class="pre">somedata</span></code> if it needs to be the same
for every test.</p>
<p>Alternatively, it can be created in each test routine that needs it if it
differs from test to test. (Some tests don’t need it at all.) In that situation,
create it like this:</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">allocate</span><span class="p">(</span><span class="n">this</span><span class="p">%</span><span class="n">somedata</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="n">this</span><span class="p">%</span><span class="n">somedata</span><span class="p">(:)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>Your tearDown method then can have code like this:</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">associated</span><span class="p">(</span><span class="n">this</span><span class="p">%</span><span class="n">somedata</span><span class="p">))</span><span class="w"> </span><span class="k">then</span>
<span class="k">  deallocate</span><span class="p">(</span><span class="n">this</span><span class="p">%</span><span class="n">somedata</span><span class="p">)</span>
<span class="k">end if</span>
</pre></div>
</div>
</section>
<section id="more-on-test-teardown">
<h3><span class="section-number">8.6.3. </span>More on test teardown<a class="headerlink" href="#more-on-test-teardown" title="Link to this heading"></a></h3>
<p>As stated in <a class="reference internal" href="#defining-a-test-class-in-order-to-define-setup-and-teardown-methods">Defining a test class in order to define setUp and tearDown methods</a>,
code in the tearDown method is executed after each test, often to do cleanup operations.</p>
<p>Using the tearDown method is recommended because tests abort if an assertion fails.
The tearDown method is still called, however, so teardown that needs to be done
still gets done, regardless of pass/fail status. Teardown code might otherwise be
skipped, which can lead other tests to fail or give unexpected results.</p>
<p>All of the tests in a single test executable run one after another. For CIME, this
means all of the tests that are defined in all <strong>.pf</strong> files in a single test directory.</p>
<p>As a result, tests can interact with each other if you don’t clean up after yourself.
In the best case, you might get a memory leak. In the worst case, the pass/fail status of tests
depends on which other tests have run previously, making your unit tests unrepeatable
and unreliable.</p>
<p><strong>To avoid this:</strong></p>
<ul class="simple">
<li><p>Deallocate any pointers that your test allocates.</p></li>
<li><p>Reset any global variables to some known, initial state.</p></li>
<li><p>Do other, similar cleanup for resources that are shared by multiple tests.</p></li>
</ul>
<p>In Fortran2003, allocatable variables are deallocated automatically when they go
out of scope, but pointers are not. Explicitly deallocate any pointers that have
been allocated, either in test setup or in the execution of the routine
you are testing.</p>
<p>You might need to move some variables from subroutine-local to the class. This is
because the tearDown method can access class instance variables, but not subroutine-local
variables.</p>
<p>CIME makes extensive use of global variables that may be used directly or
indirectly by a routine you are testing. If your test has allocated or modified
any global variables, it is important to reset them to their initial state in the
teardown portion of the test.</p>
</section>
</section>
<section id="finding-more-documentation-and-examples">
<h2><span class="section-number">8.7. </span>Finding more documentation and examples<a class="headerlink" href="#finding-more-documentation-and-examples" title="Link to this heading"></a></h2>
<section id="more-detailed-examples-in-cime">
<h3><span class="section-number">8.7.1. </span>More detailed examples in CIME<a class="headerlink" href="#more-detailed-examples-in-cime" title="Link to this heading"></a></h3>
<p>There are many examples of unit tests in CIME, some simple and some quite complex.
You can find them by looking for files with the “.pf” extension:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>find<span class="w"> </span>.<span class="w"> </span>--name<span class="w"> </span><span class="s1">&#39;*.pf&#39;</span>
</pre></div>
</div>
<p>You can also see examples of the unit test build scripts by viewing the
<strong>CMakeLists.txt</strong> files throughout the source tree.</p>
</section>
<section id="other-pfunit-documentation-sources">
<h3><span class="section-number">8.7.2. </span>Other pFUnit documentation sources<a class="headerlink" href="#other-pfunit-documentation-sources" title="Link to this heading"></a></h3>
<p>Unfortunately, the documentation inside the pFUnit repository (in the documentation and Examples directories) is out-of-date (at least as of April, 2023): much of this documentation refers to version 3 of pFUnit, which differs in some ways from version 4. However, some working examples are provided in <a class="reference external" href="https://github.com/Goddard-Fortran-Ecosystem/pFUnit_demos">https://github.com/Goddard-Fortran-Ecosystem/pFUnit_demos</a>.</p>
</section>
<section id="documentation-of-the-unit-test-build-system">
<h3><span class="section-number">8.7.3. </span>Documentation of the unit test build system<a class="headerlink" href="#documentation-of-the-unit-test-build-system" title="Link to this heading"></a></h3>
<p>The CMake build infrastructure is in <strong>$CIMEROOT/CIME/non_py/src/CMake</strong>.</p>
<p>The infrastructure for building and running tests with <strong>run_tests.py</strong> is in
<strong>$CIMEROOT/scripts/fortran_unit_testing</strong>. That directory also contains general
documentation about how to use the CIME unit test infrastructure (in the
<strong>README</strong> file) and examples (in the <strong>Examples</strong> directory).</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="porting-cime.html" class="btn btn-neutral float-left" title="7. Porting and validating CIME on a new platform" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="multi-instance.html" class="btn btn-neutral float-right" title="9. Multi-instance component functionality" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017, U.S. National Science Foundation and U.S. Department of Energy.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
     
<script>var version_json_loc = "../../../versions.json";</script>


</footer>
        </div>
      </div>
    </section>
  </div>
  

  <script type="text/javascript">
    let baseUriRegex = /(.*\/cime)\/.*/g;
    let parsedUri = baseUriRegex.exec(document.baseURI);

    if (parsedUri != null && parsedUri.length == 2) {
      let baseUri = parsedUri[1];

      $.get(`${baseUri}/versions/versions.json`, function(data) {
        let versionElement = $("#versions");

        Object.keys(data).forEach(function(key) {
          let value = data[key];

          let item = `<dd><a href="${baseUri}/versions/${key}/html/">${value}</a></dd>`

          versionElement.append(item);
        });
      });
    }
  </script>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: master
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      
      <dl id="versions">
        <dt>Versions</dt>
      </dl>
      
      
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>